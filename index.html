<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolution Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; overflow: hidden; background-color: #111827; color: #e5e7eb; }
        #simulationCanvas {
            display: block;
            background-color: #1f2937; /* Tailwind gray-800 */
            border: 1px solid #374151; /* Tailwind gray-700 */
        }
        #controls {
            background-color: #374151; /* Tailwind gray-700 */
        }
        .stat-label { color: #9ca3af; /* Tailwind gray-400 */ }
        .stat-value { color: #e5e7eb; /* Tailwind gray-200 */ }
        .modal-backdrop { background-color: rgba(0, 0, 0, 0.5); }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            background: #2563eb; cursor: pointer; border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px; background: #2563eb; cursor: pointer;
            border-radius: 50%; border: none;
        }
        .heatmap-button-active { background-color: #10b981; /* Tailwind green-500 */ }
        .heatmap-button-active:hover { background-color: #059669; /* Tailwind green-600 */ }
        .gene-active { color: #4ade80; /* Tailwind green-400 */ }
        .gene-inactive { color: #f87171; /* Tailwind red-400 */ }
        .gene-neutral { color: #cbd5e1; /* Tailwind slate-300 */ }
    </style>
</head>
<body class="flex flex-col h-screen">

    <div id="controls" class="p-4 border-b border-gray-600">
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
            <div><span class="stat-label">Organisms:</span> <span id="organismCount" class="stat-value font-semibold">0</span></div>
            <div><span class="stat-label">Elapsed Time (s):</span> <span id="elapsedTime" class="stat-value font-semibold">0</span></div>
            <div><span class="stat-label">Duplications:</span> <span id="duplicationCount" class="stat-value font-semibold">0</span></div>
            <div><span class="stat-label">Evolutions:</span> <span id="evolutionCount" class="stat-value font-semibold">0</span></div>
        </div>
        <div class="mt-3">
             <button id="resetButton" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg text-sm font-medium">Reset Simulation</button>
             <button id="pauseButton" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium ml-2">Pause</button>
        </div>
        <div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2">
            <div class="flex items-center space-x-2">
                <label for="speedSlider" class="text-sm stat-label whitespace-nowrap">Speed:</label>
                <input type="range" id="speedSlider" min="1" max="15" value="1" step="0.5" class="w-full accent-blue-600 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                <span id="speedValue" class="text-sm stat-value font-semibold w-12 text-right">1.0x</span>
            </div>
            <div class="flex items-center space-x-2">
                <label for="maxOrganismsSlider" class="text-sm stat-label whitespace-nowrap">Max Orgs:</label>
                <input type="range" id="maxOrganismsSlider" min="200" max="2000" value="900" step="50" class="w-full accent-blue-600 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                <span id="maxOrganismsValue" class="text-sm stat-value font-semibold w-16 text-right">900</span>
            </div>
        </div>
        <div class="mt-3 flex flex-wrap gap-2 items-center">
            <button id="toggleScavengerHeatmap" class="px-3 py-1 rounded-md text-xs font-medium text-white transition-colors bg-sky-600 hover:bg-sky-700">Scavenger Heatmap</button>
            <button id="togglePreyHeatmap" class="px-3 py-1 rounded-md text-xs font-medium text-white transition-colors bg-sky-600 hover:bg-sky-700">Prey (Fear) Heatmap</button>
            <button id="togglePredatorHeatmap" class="px-3 py-1 rounded-md text-xs font-medium text-white transition-colors bg-sky-600 hover:bg-sky-700">Predator Heatmap</button>
        </div>
    </div>

    <div class="flex-grow relative">
        <canvas id="simulationCanvas"></canvas>
    </div>

    <div id="organismInfoModal" class="fixed inset-0 modal-backdrop flex items-center justify-center hidden p-4 z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-gray-200 max-w-md w-full max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold" id="infoOrganismId">Organism Details</h3>
                <button id="closeInfoModal" class="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
            </div>
            <div id="infoGeneList" class="space-y-1 text-sm mb-4"></div>
            <div class="text-xs text-gray-400 mb-3">
                <p><span class="gene-active">Green:</span> Trait active / threshold met.</p>
                <p><span class="gene-inactive">Red:</span> Trait inactive / threshold not met.</p>
                <p><span class="gene-neutral">Slate:</span> Value-based gene (e.g., size, color).</p>
            </div>
            <button id="closeInfoModalButton" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">Close</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        const organismCountEl = document.getElementById('organismCount');
        const elapsedTimeEl = document.getElementById('elapsedTime');
        const duplicationCountEl = document.getElementById('duplicationCount');
        const evolutionCountEl = document.getElementById('evolutionCount');
        const resetButton = document.getElementById('resetButton');
        const pauseButton = document.getElementById('pauseButton');
        const organismInfoModal = document.getElementById('organismInfoModal');
        const infoOrganismIdEl = document.getElementById('infoOrganismId');
        const infoGeneListEl = document.getElementById('infoGeneList');
        const closeInfoModal = document.getElementById('closeInfoModal');
        const closeInfoModalButton = document.getElementById('closeInfoModalButton');
        const speedSlider = document.getElementById('speedSlider');
        const speedValueEl = document.getElementById('speedValue');
        const maxOrganismsSlider = document.getElementById('maxOrganismsSlider'); // New slider
        const maxOrganismsValueEl = document.getElementById('maxOrganismsValue'); // New slider value display
        const toggleScavengerHeatmapButton = document.getElementById('toggleScavengerHeatmap');
        const togglePreyHeatmapButton = document.getElementById('togglePreyHeatmap');
        const togglePredatorHeatmapButton = document.getElementById('togglePredatorHeatmap');

        // Simulation Parameters
        const DUPLICATION_CHANCE_PER_SECOND = 0.012;
        const EVOLUTION_CHANCE_ON_DUPLICATION = 0.025;
        const GENE_MUTATION_STRENGTH = 0.5;
        const MINOR_HUE_SHIFT_STRENGTH = 0.4;
        const MAX_GENES = 17;
        const INITIAL_GENE_COUNT = MAX_GENES;
        const BASE_SPEED = 0.001;
        const FLAGELLA_SPEED_BONUS = 25; // Speed bonus per effective flagella unit
        const HOSTILITY_THRESHOLD = 0.5;
        const FEAR_FACTOR_THRESHOLD = 0.3;
        const PREDATOR_DRIVE_THRESHOLD = 0.3;
        const SCAVENGER_THRESHOLD = 0.3;
        const CONSUMPTION_SIZE_BOOST = 0.3;
        const MAX_RADIUS_CAP = 600;
        const LIFESPAN_PER_CELLCOUNT_SECONDS = 180;
        const LIFESPAN_EXTENSION_PER_CONSUMED_CELL_SECONDS = 45;
        const LIFESPAN_EXTENSION_FROM_HUSK = 45;
        const MAX_NEARBY_CELLS_FOR_DUPLICATION = 5;
        const CROWDING_CHECK_RADIUS = 22;
        const HUSK_COLOR = 'rgba(220, 220, 220, 0.7)';
        const HUSK_DEFAULT_RADIUS = 3;
        const EATING_COOLDOWN_SECONDS = 6;
        const MIN_RADIUS_TO_EAT_BY_MULTICELLULAR = HUSK_DEFAULT_RADIUS;

        // Environment Parameters
        const NUM_CAVE_WALLS = 190;
        const MIN_WALL_LENGTH = 35;
        const MAX_WALL_LENGTH = 100;
        const WALL_THICKNESS = 20;
        const WALL_CONNECTION_PROBABILITY = 40/41;
        const MIN_VERTEX_ANGLE_DEG = 110;
        const MIN_DEFLECTION_FROM_STRAIGHT_DEG = 5;
        const NUM_FOOD_DISPENSERS = 3;
        const FOOD_DISPENSER_RATE_SECONDS = 6;
        const FOOD_DISPENSER_HUSK_SPEED = 30;
        const NUM_SALT_REGIONS = 1;
        const SALT_REGION_LIFESPAN_REDUCTION = 0.3;
        const SALT_REGION_MUTATION_BOOST = 0.3;
        const SALT_REGION_TINT_COLOR = 'rgba(255, 255, 55, 0.07)';

        // Plasmodium Parameters
        const PLASMODIUM_EXPRESSION_THRESHOLD = 0.7;
        const PLASMODIUM_RADIUS_MULTIPLIER = 7.0;
        const PLASMODIUM_TINT_ALPHA = 0.15;

        // Heatmap Parameters
        const HEATMAP_ALPHA = 0.08;
        const HEATMAP_RADIUS_MULTIPLIER = 5;
        const HEATMAP_SCAVENGER_COLOR = `rgba(255, 215, 0, ${HEATMAP_ALPHA})`; // Gold
        const HEATMAP_PREY_COLOR = `rgba(65, 105, 225, ${HEATMAP_ALPHA})`;    // Royal Blue
        const HEATMAP_PREDATOR_COLOR = `rgba(220, 20, 60, ${HEATMAP_ALPHA})`;  // Crimson

        // Existing New Gene Parameters
        const WALL_ATTRACTION_THRESHOLD = 0.7;
        const WALL_ATTRACTION_FORCE = 0.05;
        const HERD_MENTALITY_THRESHOLD = 0.45;
        const HERD_DETECTION_RADIUS_MULTIPLIER = 1.5;
        const HERD_FORCE = 0.03;
        const EGG_LAYING_THRESHOLD = 0.6;
        const EGG_DURATION_SECONDS = 140;
        const EGG_LIFESPAN_FOOD_BONUS = 1.5;
        const EGG_COLOR = 'rgba(255, 255, 255, 0.9)';
        const EGG_STRENGTH = 0.01;

        // Dwelling Gene Parameters
        const DWELLING_GENE_THRESHOLD = 0.6;
        const DWELLING_LIFESPAN_SATISFACTION_RATIO = 0.75;
        const DWELLING_FORCE = 0.04;
        const DWELLING_REACH_THRESHOLD = 10;

        // Gene Indices & Names
        const GENE_HUE = 0; const GENE_BASE_SIZE = 1; const GENE_DUP_RATE = 2;
        const GENE_FLAGELLA = 3; const GENE_HOSTILITY = 4; const GENE_SIGHT_RANGE = 5;
        const GENE_FEAR_FACTOR = 6; const GENE_PREDATOR_DRIVE = 7; const GENE_COMPLEXITY = 8;
        const GENE_SCAVENGER = 9; const GENE_SALT_TOLERANCE = 10; const GENE_SALT_AVOIDANCE = 11;
        const GENE_PLASMODIUM = 12; const GENE_WALL_ATTRACTION = 13;
        const GENE_HERD_MENTALITY = 14; const GENE_EGG_LAYING = 15;
        const GENE_DWELLING = 16;
        const GENE_NAMES = [
            "Hue", "BaseSize", "Dup.Rate", "Flagella", "Hostility", "SightRange",
            "Fear", "Predator", "Complexity", "Scavenger", "SaltTolerance", "SaltAvoidance",
            "Plasmodium", "WallAttract", "HerdMental", "EggLayer", "Dwelling"
        ];

        // Gene Thresholds for Modal Display
        const GENE_THRESHOLDS = {
            [GENE_HOSTILITY]: HOSTILITY_THRESHOLD,
            [GENE_FEAR_FACTOR]: FEAR_FACTOR_THRESHOLD,
            [GENE_PREDATOR_DRIVE]: PREDATOR_DRIVE_THRESHOLD,
            [GENE_SCAVENGER]: SCAVENGER_THRESHOLD,
            [GENE_SALT_AVOIDANCE]: 0.5, // Behavior activates if gene > 0.5
            [GENE_PLASMODIUM]: PLASMODIUM_EXPRESSION_THRESHOLD,
            [GENE_WALL_ATTRACTION]: WALL_ATTRACTION_THRESHOLD,
            [GENE_HERD_MENTALITY]: HERD_MENTALITY_THRESHOLD,
            [GENE_EGG_LAYING]: EGG_LAYING_THRESHOLD,
            [GENE_DWELLING]: DWELLING_GENE_THRESHOLD,
            [GENE_FLAGELLA]: 0.01 // Special case: considered "active" if > 0.01 for speed bonus
        };


        // Simulation State
        let organisms = [];
        let husks = [];
        let walls = [];
        let foodDispensers = [];
        let saltRegions = [];
        let simulationTime = 0;
        let lastTickTime = 0;
        let totalDuplications = 0;
        let totalEvolutions = 0;
        let isPaused = false;
        let animationFrameId;
        let gameSpeedMultiplier = 1.0;
        let maxOrganismsLimit = 900; // New: Max organism limit, default 900
        let showScavengerHeatmap = true; // Default ON
        let showPreyHeatmap = true;     // Default ON
        let showPredatorHeatmap = true;  // Default ON
        let viewScale = 1.0;
        let viewOffsetX = 0;
        let viewOffsetY = 0;
        let worldWidth, worldHeight;

        function resizeCanvas() {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            if (!worldWidth || !worldHeight) {
                 worldWidth = canvas.width * 1.5; // Initial world size relative to canvas
                 worldHeight = canvas.height * 1.5;
            }
            clampViewOffset();
        }

        function calculateCellCount(genes) {
            return Math.max(1, Math.floor(1 + (genes[GENE_COMPLEXITY] || 0) * 4));
        }
        
        function createOrganism(x, y, genesOverride, parentBirthX, parentBirthY) {
            const defaultGenes = Array(INITIAL_GENE_COUNT).fill(0).map(() => Math.random() * 0.3 + 0.1);
            const newGenes = genesOverride ? [...genesOverride] : defaultGenes;
            while (newGenes.length < MAX_GENES) { newGenes.push(Math.random() * 0.3 + 0.1); }
            
            const organism = {
                id: Math.random().toString(36).substr(2, 9), 
                x, y, 
                birthX: parentBirthX !== undefined ? parentBirthX : x,
                birthY: parentBirthY !== undefined ? parentBirthY : y,
                genes: newGenes,
                radius: 5, color: 'hsl(0, 100%, 50%)', actualDuplicationChance: DUPLICATION_CHANCE_PER_SECOND,
                speed: BASE_SPEED, flagellaCount: 0, isHostile: false, sightRange: 0,
                flees: false, hunts: false, isScavenging: false, 
                targetOrganism: null, targetHusk: null, targetWallPoint: null, targetHerdCenter: null, targetDwellingPoint: null,
                strength: 0, vx: (Math.random() - 0.5) * 0.1, vy: (Math.random() - 0.5) * 0.1, 
                age: 0, cellCount: 1, timeToLive: LIFESPAN_PER_CELLCOUNT_SECONDS, initialTimeToLive: LIFESPAN_PER_CELLCOUNT_SECONDS,
                eatCooldown: 0, 
                avoidsSalt: false, 
                isPlasmodiumActive: false, plasmodiumEffectRadius: 0, plasmodiumTargetHusk: null,
                isAttractedToWalls: false, wallAttractionFactor: 0,
                seeksHerd: false, herdDrive: 0,
                isEggLayer: false, isEgg: false, eggTimer: 0,
                canDwelling: false, isDwelling: false, dwellingGeneValue: 0,
            };
            organism.cellCount = calculateCellCount(organism.genes);
            organism.initialTimeToLive = LIFESPAN_PER_CELLCOUNT_SECONDS * organism.cellCount;
            organism.timeToLive = organism.initialTimeToLive;
            return organism;
        }
        
        function interpretGenes(organism) {
            const g = organism.genes;
            if (organism.isEgg) {
                organism.color = EGG_COLOR;
                organism.speed = 0;
                organism.flagellaCount = 0;
                organism.isHostile = false; 
                organism.sightRange = 0;
                organism.strength = EGG_STRENGTH; 
                organism.isScavenger = false;
                organism.isAttractedToWalls = false;
                organism.seeksHerd = false;
                organism.isPlasmodiumActive = false; 
                organism.plasmodiumEffectRadius = 0;
                organism.canDwelling = false;
                organism.isDwelling = false;
                return; 
            }

            organism.color = `hsl(${Math.floor((g[GENE_HUE] || 0) * 360)}, 70%, 60%)`;
            organism.cellCount = calculateCellCount(g);
            const minRadius = 3; const maxRadiusForGene = 8;
            let baseRadius = minRadius + ((g[GENE_BASE_SIZE] || 0) * (maxRadiusForGene - minRadius));
            const complexityFactor = 1 + (g[GENE_COMPLEXITY] || 0) * 1;
            organism.radius = baseRadius * complexityFactor;
            organism.radius = Math.min(organism.radius, MAX_RADIUS_CAP);
            const dupRateGene = g[GENE_DUP_RATE] === undefined ? 0.5 : g[GENE_DUP_RATE];
            organism.actualDuplicationChance = DUPLICATION_CHANCE_PER_SECOND * (0.5 + dupRateGene);
            
            const rawFlagellaValue = g[GENE_FLAGELLA] || 0;
            organism.flagellaCount = Math.floor(rawFlagellaValue * 3); 
            if (rawFlagellaValue > 0.01) { 
                const effectiveFlagellaForSpeed = Math.max(1, organism.flagellaCount); 
                organism.speed = BASE_SPEED + effectiveFlagellaForSpeed * FLAGELLA_SPEED_BONUS;
            } else {
                organism.speed = BASE_SPEED;
            }
            
            organism.isHostile = (g[GENE_HOSTILITY] || 0) > HOSTILITY_THRESHOLD;
            organism.sightRange = (g[GENE_SIGHT_RANGE] || 0) * 150;
            organism.strength = organism.cellCount; 
            organism.isScavenger = !organism.isHostile && (g[GENE_SCAVENGER] || 0) > SCAVENGER_THRESHOLD && organism.sightRange > 0;
            organism.saltToleranceFactor = g[GENE_SALT_TOLERANCE] || 0; 
            organism.avoidsSalt = (g[GENE_SALT_AVOIDANCE] || 0) > 0.5;
            organism.isPlasmodiumActive = (g[GENE_PLASMODIUM] || 0) >= PLASMODIUM_EXPRESSION_THRESHOLD;
            if (organism.isPlasmodiumActive) {
                organism.plasmodiumEffectRadius = organism.radius * PLASMODIUM_RADIUS_MULTIPLIER;
            } else {
                organism.plasmodiumEffectRadius = 0;
            }

            organism.wallAttractionFactor = g[GENE_WALL_ATTRACTION] || 0;
            organism.isAttractedToWalls = organism.wallAttractionFactor > WALL_ATTRACTION_THRESHOLD;
            
            organism.herdDrive = g[GENE_HERD_MENTALITY] || 0;
            organism.seeksHerd = organism.herdDrive > HERD_MENTALITY_THRESHOLD;

            organism.isEggLayer = (g[GENE_EGG_LAYING] || 0) > EGG_LAYING_THRESHOLD;

            organism.dwellingGeneValue = g[GENE_DWELLING] || 0;
            organism.canDwelling = organism.dwellingGeneValue > DWELLING_GENE_THRESHOLD;
        }

        function duplicateOrganism(parent, offspringX, offspringY, isInSaltRegion) {
            totalDuplications++;
            const newGenes = [...parent.genes];
            let currentEvolutionChance = EVOLUTION_CHANCE_ON_DUPLICATION;
            if (isInSaltRegion) {
                currentEvolutionChance += SALT_REGION_MUTATION_BOOST * (1 - (parent.saltToleranceFactor || 0));
            }

            let mutatedNonHueGene = false;
            if (Math.random() < currentEvolutionChance) {
                totalEvolutions++;
                let geneIndexToMutate;
                if (MAX_GENES > 1) {
                    do { geneIndexToMutate = Math.floor(Math.random() * MAX_GENES); } while (geneIndexToMutate === GENE_HUE);
                } else {
                    geneIndexToMutate = 0; 
                }

                const oldValue = newGenes[geneIndexToMutate];
                newGenes[geneIndexToMutate] += (Math.random() - 0.5) * GENE_MUTATION_STRENGTH;
                if (geneIndexToMutate === GENE_COMPLEXITY) { newGenes[geneIndexToMutate] = Math.max(0, newGenes[geneIndexToMutate]); }
                else { newGenes[geneIndexToMutate] = Math.max(0, Math.min(1, newGenes[geneIndexToMutate])); }
                
                if (newGenes[geneIndexToMutate] !== oldValue) {
                    mutatedNonHueGene = true;
                }
            }
            
            if (mutatedNonHueGene || (Math.random() < currentEvolutionChance && MAX_GENES > 0 && newGenes[GENE_HUE] !== undefined) ) {
                 newGenes[GENE_HUE] = (newGenes[GENE_HUE] || 0) + (Math.random() - 0.5) * MINOR_HUE_SHIFT_STRENGTH;
                 newGenes[GENE_HUE] = (newGenes[GENE_HUE] + 1) % 1;
            }

            const offspring = createOrganism(offspringX, offspringY, newGenes, parent.birthX, parent.birthY);
            
            if (parent.isEggLayer) {
                offspring.isEgg = true;
                offspring.eggTimer = EGG_DURATION_SECONDS;
                offspring.strength = EGG_STRENGTH; 
                offspring.birthX = offspringX;
                offspring.birthY = offspringY;
            }
            interpretGenes(offspring); 
            return offspring;
        }

        function onSegment(px, py, qx, qy, rx, ry) { return (qx <= Math.max(px, rx) && qx >= Math.min(px, rx) && qy <= Math.max(py, ry) && qy >= Math.min(py, ry)); }
        function orientation(px, py, qx, qy, rx, ry) { const val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy); if (val === 0) return 0; return (val > 0) ? 1 : 2; }
        function segmentsIntersect(p1x, p1y, q1x, q1y, p2x, p2y, q2x, q2y) { const o1 = orientation(p1x, p1y, q1x, q1y, p2x, p2y); const o2 = orientation(p1x, p1y, q1x, q1y, q2x, q2y); const o3 = orientation(p2x, p2y, q2x, q2y, p1x, p1y); const o4 = orientation(p2x, p2y, q2x, q2y, q1x, q1y); if (o1 !== 0 && o2 !== 0 && o3 !== 0 && o4 !== 0) { if (o1 !== o2 && o3 !== o4) return true; } if (o1 === 0 && onSegment(p1x, p1y, p2x, p2y, q1x, q1y)) return true; if (o2 === 0 && onSegment(p1x, p1y, q2x, q2y, q1x, q1y)) return true; if (o3 === 0 && onSegment(p2x, p2y, p1x, p1y, q2x, q2y)) return true; if (o4 === 0 && onSegment(p2x, p2y, q1x, q1y, q2x, q2y)) return true; return false;  }
        function getClosestPointOnLineSegment(pX,pY,l1X,l1Y,l2X,l2Y){ const l2_sq=(l1X-l2X)**2+(l1Y-l2Y)**2; if(l2_sq===0)return {x:l1X,y:l1Y, distSq: (pX-l1X)**2 + (pY-l1Y)**2}; let t=((pX-l1X)*(l2X-l1X)+(pY-l1Y)*(l2Y-l1Y))/l2_sq; t=Math.max(0,Math.min(1,t)); const closestX = l1X+t*(l2X-l1X); const closestY = l1Y+t*(l2Y-l1Y); return {x:closestX, y:closestY, distSq: (pX-closestX)**2 + (pY-closestY)**2 }; }

        function generateEnvironment() { walls = []; foodDispensers = []; saltRegions = []; let attempts = 0; const maxAttemptsPerWall = 20; for (let i = 0; i < NUM_CAVE_WALLS && attempts < NUM_CAVE_WALLS * maxAttemptsPerWall; ) { let x1_cand, y1_cand, x2_cand, y2_cand; let length = MIN_WALL_LENGTH + Math.random() * (MAX_WALL_LENGTH - MIN_WALL_LENGTH); let connectedToThisWall = null; let newWallIsValid = true; if (walls.length > 0 && Math.random() < WALL_CONNECTION_PROBABILITY) { const parentWall = walls[Math.floor(Math.random() * walls.length)]; connectedToThisWall = parentWall; let connectionPointX, connectionPointY, parentOtherEndX, parentOtherEndY; if (Math.random() < 0.5) { connectionPointX = parentWall.x1; connectionPointY = parentWall.y1; parentOtherEndX = parentWall.x2; parentOtherEndY = parentWall.y2; } else { connectionPointX = parentWall.x2; connectionPointY = parentWall.y2; parentOtherEndX = parentWall.x1; parentOtherEndY = parentWall.y1; } x1_cand = connectionPointX; y1_cand = connectionPointY; const parentDirectionX = connectionPointX - parentOtherEndX; const parentDirectionY = connectionPointY - parentOtherEndY; const parentSegmentAngle = Math.atan2(parentDirectionY, parentDirectionX); const minVertexAngleRad = MIN_VERTEX_ANGLE_DEG * Math.PI / 180; const maxVertexAngleRad = (180 - MIN_DEFLECTION_FROM_STRAIGHT_DEG) * Math.PI / 180; const minDeflectionRad = Math.PI - maxVertexAngleRad; const maxDeflectionRad = Math.PI - minVertexAngleRad; if (minDeflectionRad >= maxDeflectionRad) { newWallIsValid = false; } else { let deflection = minDeflectionRad + Math.random() * (maxDeflectionRad - minDeflectionRad); const signedDeflection = (Math.random() < 0.5 ? 1 : -1) * deflection; const newWallAngle = parentSegmentAngle + signedDeflection; x2_cand = x1_cand + Math.cos(newWallAngle) * length; y2_cand = y1_cand + Math.sin(newWallAngle) * length; } } else { x1_cand = Math.random() * worldWidth; y1_cand = Math.random() * worldHeight; const angle = Math.random() * Math.PI * 2; x2_cand = x1_cand + Math.cos(angle) * length; y2_cand = y1_cand + Math.sin(angle) * length; } if (!newWallIsValid) { attempts++; continue; } x1_cand = Math.max(WALL_THICKNESS/2, Math.min(worldWidth - WALL_THICKNESS/2, x1_cand)); y1_cand = Math.max(WALL_THICKNESS/2, Math.min(worldHeight - WALL_THICKNESS/2, y1_cand)); x2_cand = Math.max(WALL_THICKNESS/2, Math.min(worldWidth - WALL_THICKNESS/2, x2_cand)); y2_cand = Math.max(WALL_THICKNESS/2, Math.min(worldHeight - WALL_THICKNESS/2, y2_cand)); if (Math.sqrt((x2_cand - x1_cand)**2 + (y2_cand - y1_cand)**2) < MIN_WALL_LENGTH * 0.5) { newWallIsValid = false; } if (newWallIsValid) { for (const existingWall of walls) { if (existingWall === connectedToThisWall) continue; if (segmentsIntersect(x1_cand, y1_cand, x2_cand, y2_cand, existingWall.x1, existingWall.y1, existingWall.x2, existingWall.y2)) { newWallIsValid = false; break; } } } if (newWallIsValid) { walls.push({ x1: x1_cand, y1: y1_cand, x2: x2_cand, y2: y2_cand, thickness: WALL_THICKNESS }); i++; } attempts++; } for (let i = 0; i < NUM_FOOD_DISPENSERS; i++) { foodDispensers.push({ x: Math.random()*worldWidth, y: Math.random()*worldHeight, radius:10, nextDispenseTime: simulationTime + Math.random()*FOOD_DISPENSER_RATE_SECONDS*2 }); } for (let i = 0; i < NUM_SALT_REGIONS; i++) { const regionWidth = worldWidth*(0.1+Math.random()*0.4); const regionHeight = worldHeight*(0.1+Math.random()*0.4); saltRegions.push({ x:Math.random()*(worldWidth-regionWidth), y:Math.random()*(worldHeight-regionHeight), width:regionWidth, height:regionHeight }); } }
        
        function initSimulation() {
            organisms = []; husks = []; simulationTime = 0; lastTickTime = performance.now();
            totalDuplications = 0; totalEvolutions = 0; isPaused = false;
            pauseButton.textContent = "Pause"; viewScale = 1.0; viewOffsetX = 0; viewOffsetY = 0; 
            
            gameSpeedMultiplier = parseFloat(speedSlider.value); // Ensure speed slider reflects initial value
            speedValueEl.textContent = `${gameSpeedMultiplier.toFixed(1)}x`;
            
            maxOrganismsLimit = parseInt(maxOrganismsSlider.value); // Ensure max orgs slider reflects initial value
            maxOrganismsValueEl.textContent = maxOrganismsLimit;

            showScavengerHeatmap = true; // Default ON
            showPreyHeatmap = true;     // Default ON
            showPredatorHeatmap = true;  // Default ON
            updateHeatmapButtonStates(); // Update buttons to reflect initial state

            if (!worldWidth) { // Initialize world size if not already set
                worldWidth = canvas.width * 1.5; 
                worldHeight = canvas.height * 1.5; 
            }
            
            generateEnvironment();
            
            const initialGenes = Array(MAX_GENES).fill(0);
            initialGenes[GENE_HUE]=Math.random(); initialGenes[GENE_BASE_SIZE]=0.1; initialGenes[GENE_DUP_RATE]=0.1; initialGenes[GENE_FLAGELLA]=0;
            initialGenes[GENE_HOSTILITY]=0.3; initialGenes[GENE_SIGHT_RANGE]=0; initialGenes[GENE_FEAR_FACTOR]=0.2; initialGenes[GENE_PREDATOR_DRIVE]=0.2;
            initialGenes[GENE_COMPLEXITY]=0; initialGenes[GENE_SCAVENGER]=0.2; 
            initialGenes[GENE_SALT_TOLERANCE]=0.1; initialGenes[GENE_SALT_AVOIDANCE]=0.4; initialGenes[GENE_PLASMODIUM] = 0.4;
            initialGenes[GENE_WALL_ATTRACTION] = 0.1; 
            initialGenes[GENE_HERD_MENTALITY] = 0.3;
            initialGenes[GENE_EGG_LAYING] = 0.4;
            initialGenes[GENE_DWELLING] = 0.2;

            const initialOrganism = createOrganism(worldWidth/2, worldHeight/2, initialGenes);
            interpretGenes(initialOrganism); organisms.push(initialOrganism);
            if (animationFrameId) cancelAnimationFrame(animationFrameId); gameLoop();
        }

        function updateStats() { organismCountEl.textContent=organisms.length; elapsedTimeEl.textContent=Math.floor(simulationTime); duplicationCountEl.textContent=totalDuplications; evolutionCountEl.textContent=totalEvolutions; }
        function screenToWorld(screenX, screenY) { const rect=canvas.getBoundingClientRect(); const canvasX=screenX-rect.left; const canvasY=screenY-rect.top; return {x:(canvasX/viewScale)+viewOffsetX, y:(canvasY/viewScale)+viewOffsetY}; }
        function worldToScreen(worldX, worldY) { return {x:(worldX-viewOffsetX)*viewScale, y:(worldY-viewOffsetY)*viewScale}; }
        function clampViewOffset() { const minScaleX=canvas.width/worldWidth; const minScaleY=canvas.height/worldHeight; const minScale=Math.max(minScaleX,minScaleY); viewScale=Math.max(minScale,viewScale); viewScale=Math.min(5,viewScale); const scaledCanvasWidth=canvas.width/viewScale; const scaledCanvasHeight=canvas.height/viewScale; let minViewOffsetX=0; let maxViewOffsetX=worldWidth-scaledCanvasWidth; let minViewOffsetY=0; let maxViewOffsetY=worldHeight-scaledCanvasHeight; if(scaledCanvasWidth>=worldWidth){viewOffsetX=(worldWidth-scaledCanvasWidth)/2;}else{viewOffsetX=Math.max(minViewOffsetX,Math.min(viewOffsetX,maxViewOffsetX));} if(scaledCanvasHeight>=worldHeight){viewOffsetY=(worldHeight-scaledCanvasHeight)/2;}else{viewOffsetY=Math.max(minViewOffsetY,Math.min(viewOffsetY,maxViewOffsetY));}}
        function isPointInSaltRegion(x,y){ for(const region of saltRegions){if(x>=region.x && x<=region.x+region.width && y>=region.y && y<=region.y+region.height){return region;}} return null;}
        function findClosestWallPoint(organism) { let closestWall = null; let closestPoint = null; let minDistanceSq = Infinity; for (const wall of walls) { const pointInfo = getClosestPointOnLineSegment(organism.x, organism.y, wall.x1, wall.y1, wall.x2, wall.y2); if (pointInfo.distSq < minDistanceSq) { minDistanceSq = pointInfo.distSq; closestPoint = { x: pointInfo.x, y: pointInfo.y }; closestWall = wall; } } return closestPoint; }


        function update(currentTime) {
            if (isPaused) return;
            let rawDeltaTime = (currentTime - lastTickTime) / 1000;
            if (rawDeltaTime <= 0) { lastTickTime = currentTime; return; } // Avoid issues with timestamp irregularities
            const deltaTime = rawDeltaTime * gameSpeedMultiplier;
            simulationTime += deltaTime;
            const newOrganisms = []; const deadOrConsumedOrganismIds = new Set(); const consumedHuskIds = new Set();

            foodDispensers.forEach(dispenser => { if (simulationTime >= dispenser.nextDispenseTime) { const angle = Math.random()*Math.PI*2; const husk={id:'husk_dispensed_'+Date.now()+'_'+Math.random(),x:dispenser.x,y:dispenser.y,radius:HUSK_DEFAULT_RADIUS,vx:Math.cos(angle)*FOOD_DISPENSER_HUSK_SPEED,vy:Math.sin(angle)*FOOD_DISPENSER_HUSK_SPEED,isDispensed:true,timeToLiveDispensed:60, cellCount:1}; husks.push(husk); dispenser.nextDispenseTime = simulationTime + (Math.random()*0.5+0.75)*FOOD_DISPENSER_RATE_SECONDS;}});
            husks.forEach(husk => { if (husk.isDispensed) { husk.x+=husk.vx*deltaTime; husk.y+=husk.vy*deltaTime; husk.vx*=0.98; husk.vy*=0.98; husk.timeToLiveDispensed-=deltaTime; if(husk.timeToLiveDispensed<=0){consumedHuskIds.add(husk.id);} if(husk.x-husk.radius<0||husk.x+husk.radius>worldWidth||husk.y-husk.radius<0||husk.y+husk.radius>worldHeight){consumedHuskIds.add(husk.id);} walls.forEach(wall=>{const closestPoint=getClosestPointOnLineSegment(husk.x,husk.y,wall.x1,wall.y1,wall.x2,wall.y2); const dx=husk.x-closestPoint.x; const dy=husk.y-closestPoint.y; const distSq=dx*dx+dy*dy; const totalRadiusSq=(husk.radius+wall.thickness/2)**2; if(distSq<totalRadiusSq){consumedHuskIds.add(husk.id);}});}});

            organisms.forEach(org => {
                if(deadOrConsumedOrganismIds.has(org.id))return; 
                org.age+=deltaTime; 
                if(org.eatCooldown>0)org.eatCooldown-=deltaTime; 
                const currentSaltRegion=isPointInSaltRegion(org.x,org.y);
                
                if (org.isEgg) {
                    org.eggTimer -= deltaTime;
                    if (org.eggTimer <= 0) {
                        org.isEgg = false;
                        org.birthX = org.x; 
                        org.birthY = org.y;
                        org.initialTimeToLive = LIFESPAN_PER_CELLCOUNT_SECONDS * org.cellCount;
                        org.timeToLive = org.initialTimeToLive; 
                        interpretGenes(org); 
                    } else {
                        org.vx = 0; org.vy = 0;
                        org.x=Math.max(org.radius,Math.min(worldWidth-org.radius,org.x));
                        org.y=Math.max(org.radius,Math.min(worldHeight-org.radius,org.y));
                        return; 
                    }
                }
                
                if(org.age>=org.timeToLive){deadOrConsumedOrganismIds.add(org.id); husks.push({id:'husk_'+org.id+'_'+Date.now(),x:org.x,y:org.y,radius:org.radius*0.5,cellCount:org.cellCount}); return;}

                org.plasmodiumTargetHusk = null; 
                if (org.isPlasmodiumActive && org.plasmodiumEffectRadius > 0) {
                    let closestHuskInPlasma = null; let minDistSqToHuskInPlasma = Infinity;
                    husks.forEach(husk => {
                        if (consumedHuskIds.has(husk.id)) return;
                        const dx = husk.x - org.x; const dy = husk.y - org.y; const distSq = dx*dx + dy*dy;
                        if (distSq < (org.plasmodiumEffectRadius)**2 ) { 
                            if (distSq < minDistSqToHuskInPlasma) { minDistSqToHuskInPlasma = distSq; closestHuskInPlasma = husk; }
                        }
                    });
                    if (closestHuskInPlasma) { org.plasmodiumTargetHusk = { x: closestHuskInPlasma.x, y: closestHuskInPlasma.y, id: closestHuskInPlasma.id }; }
                }

                if(Math.random()<org.actualDuplicationChance*deltaTime){
                    const angle=Math.random()*Math.PI*2; const offset=org.radius*2.5;
                    let offspringX = org.x + Math.cos(angle)*offset; let offspringY = org.y + Math.sin(angle)*offset;
                    if (org.isPlasmodiumActive && org.plasmodiumTargetHusk) {
                        const targetHuskStillExists = husks.find(h => h.id === org.plasmodiumTargetHusk.id && !consumedHuskIds.has(h.id));
                        if (targetHuskStillExists) { offspringX = org.plasmodiumTargetHusk.x; offspringY = org.plasmodiumTargetHusk.y; }
                    }
                    let potentialNewX = offspringX; let potentialNewY = offspringY;
                    potentialNewX=Math.max(org.radius,Math.min(worldWidth-org.radius,potentialNewX));
                    potentialNewY=Math.max(org.radius,Math.min(worldHeight-org.radius,potentialNewY));
                    let nearbyCellCount=0; const crowdingCheckRadiusSq=CROWDING_CHECK_RADIUS*CROWDING_CHECK_RADIUS;
                    for(const other of organisms){if(org.id===other.id)continue;const dx=other.x-potentialNewX;const dy=other.y-potentialNewY;if((dx*dx+dy*dy)<crowdingCheckRadiusSq)nearbyCellCount+=other.cellCount;}
                    for(const newOrgCand of newOrganisms){const dx=newOrgCand.x-potentialNewX;const dy=newOrgCand.y-potentialNewY;if((dx*dx+dy*dy)<crowdingCheckRadiusSq)nearbyCellCount+=newOrgCand.cellCount;}
                    
                    // Use maxOrganismsLimit here
                    if(nearbyCellCount<=MAX_NEARBY_CELLS_FOR_DUPLICATION && (organisms.length + newOrganisms.length) < maxOrganismsLimit){
                        newOrganisms.push(duplicateOrganism(org,potentialNewX,potentialNewY,!!currentSaltRegion));
                    }
                }
                
                org.flees=false;org.hunts=false;org.isScavenging=false; org.isDwelling = false;
                org.targetOrganism=null;org.targetHusk=null; org.targetWallPoint = null; org.targetHerdCenter = null; org.targetDwellingPoint = null;
                interpretGenes(org); 
                
                let wantsToLeaveSalt=false; if(org.avoidsSalt&&currentSaltRegion&&(org.saltToleranceFactor<0.8)){wantsToLeaveSalt=true;const saltCenterX=currentSaltRegion.x+currentSaltRegion.width/2;const saltCenterY=currentSaltRegion.y+currentSaltRegion.height/2;org.vx+=(org.x-saltCenterX)*0.1;org.vy+=(org.y-saltCenterY)*0.1;}
                
                if(org.sightRange>0&&org.eatCooldown<=0&&!wantsToLeaveSalt){
                    let bestPrey=null;let closestPreyDist=Infinity;let strongestThreat=null;let closestThreatDist=Infinity;
                    let potentialScavengerThreat=null;let closestScavengerThreatDist=Infinity;let bestHuskTarget=null;let closestHuskDist=Infinity;
                    let herdMembers = [];

                    organisms.forEach(other=>{if(org===other||deadOrConsumedOrganismIds.has(other.id)||other.isEgg)return;const dx=other.x-org.x;const dy=other.y-org.y;const distance=Math.sqrt(dx*dx+dy*dy)-other.radius-org.radius; if(distance<org.sightRange){ const canWinEngagement=(org.strength>other.strength)||(org.strength===other.strength&&org.radius>other.radius); const isEdibleByMulticell=!(org.cellCount>1&&other.cellCount===1&&other.radius<MIN_RADIUS_TO_EAT_BY_MULTICELLULAR); if((org.genes[GENE_PREDATOR_DRIVE]||0)>PREDATOR_DRIVE_THRESHOLD&&org.isHostile&&canWinEngagement&&isEdibleByMulticell&&JSON.stringify(org.genes)!==JSON.stringify(other.genes)){if(distance<closestPreyDist){closestPreyDist=distance;bestPrey=other;}} const isThreat=other.isHostile&&(other.strength>org.strength*1.5||(org.isHostile&&other.strength>org.strength&&!canWinEngagement)); if(((org.genes[GENE_FEAR_FACTOR]||0)>FEAR_FACTOR_THRESHOLD||(org.isHostile&&isThreat))&&isThreat){if(distance<closestThreatDist){closestThreatDist=distance;strongestThreat=other;}} if(org.isScavenger&&(org.genes[GENE_FEAR_FACTOR]||0)>(org.genes[GENE_SCAVENGER]||0)*0.5&&other.isHostile){if(distance<closestScavengerThreatDist){closestScavengerThreatDist=distance;potentialScavengerThreat=other;}} if (org.seeksHerd && distance < org.sightRange * HERD_DETECTION_RADIUS_MULTIPLIER) { const isDirectThreatOrPrey = (strongestThreat && strongestThreat.id === other.id) || (bestPrey && bestPrey.id === other.id); if (!isDirectThreatOrPrey) { herdMembers.push(other); } } }});
                    if(org.isScavenger){husks.forEach(husk=>{if(consumedHuskIds.has(husk.id))return;const dx=husk.x-org.x;const dy=husk.y-org.y;const distance=Math.sqrt(dx*dx+dy*dy)-husk.radius-org.radius;if(distance<org.sightRange){if(distance<closestHuskDist && husk.radius <= org.radius){closestHuskDist=distance;bestHuskTarget=husk;}}});} 
                    
                    if(strongestThreat){org.flees=true;org.targetOrganism=strongestThreat;}
                    else if(org.isScavenger&&potentialScavengerThreat){org.flees=true;org.targetOrganism=potentialScavengerThreat;}
                    else if(bestPrey&&org.isHostile){org.hunts=true;org.targetOrganism=bestPrey;}
                    else if(bestHuskTarget&&org.isScavenger&&!org.flees){org.isScavenging=true;org.targetHusk=bestHuskTarget;}
                    else if (org.canDwelling && org.timeToLive > org.initialTimeToLive * DWELLING_LIFESPAN_SATISFACTION_RATIO && !org.flees && !org.hunts && !org.isScavenging) {
                        const distToBirthSq = (org.x - org.birthX)**2 + (org.y - org.birthY)**2;
                        if (distToBirthSq > (DWELLING_REACH_THRESHOLD * 2)**2) { 
                             org.isDwelling = true;
                             org.targetDwellingPoint = { x: org.birthX, y: org.birthY };
                        }
                    } else if (org.isAttractedToWalls && walls.length > 0 && !org.flees && !org.hunts && !org.isScavenging && !org.isDwelling) {
                        org.targetWallPoint = findClosestWallPoint(org);
                    } else if (org.seeksHerd && herdMembers.length > 0 && !org.flees && !org.hunts && !org.isScavenging && !org.isDwelling && !org.targetWallPoint) {
                        let sumX = 0, sumY = 0;
                        herdMembers.forEach(member => { sumX += member.x; sumY += member.y; });
                        org.targetHerdCenter = { x: sumX / herdMembers.length, y: sumY / herdMembers.length };
                    }
                }
                
                let targetVx=org.vx;let targetVy=org.vy;
                if(org.targetOrganism){const target=organisms.find(o=>o.id===org.targetOrganism.id&&!deadOrConsumedOrganismIds.has(o.id));if(target){const dirX=target.x-org.x;const dirY=target.y-org.y;const distToTarget=Math.sqrt(dirX*dirX+dirY*dirY);if(distToTarget>0){const moveFactor=org.flees?-1:1;targetVx=(dirX/distToTarget)*org.speed*moveFactor;targetVy=(dirY/distToTarget)*org.speed*moveFactor;}}}
                else if(org.targetHusk){const target=husks.find(h=>h.id===org.targetHusk.id&&!consumedHuskIds.has(h.id));if(target){const dirX=target.x-org.x;const dirY=target.y-org.y;const distToTarget=Math.sqrt(dirX*dirX+dirY*dirY);if(distToTarget>0){targetVx=(dirX/distToTarget)*org.speed;targetVy=(dirY/distToTarget)*org.speed;}}}
                else if (org.targetDwellingPoint) { 
                    const dirX = org.targetDwellingPoint.x - org.x;
                    const dirY = org.targetDwellingPoint.y - org.y;
                    const distToTarget = Math.sqrt(dirX*dirX + dirY*dirY);
                    if (distToTarget > DWELLING_REACH_THRESHOLD) { 
                        targetVx = (dirX / distToTarget) * org.speed * org.dwellingGeneValue * DWELLING_FORCE;
                        targetVy = (dirY / distToTarget) * org.speed * org.dwellingGeneValue * DWELLING_FORCE;
                    } else { 
                        org.isDwelling = false; 
                        org.targetDwellingPoint = null;
                        targetVx = 0; targetVy = 0; 
                    }
                }
                else if (org.targetWallPoint) { const dirX = org.targetWallPoint.x - org.x; const dirY = org.targetWallPoint.y - org.y; const distToTarget = Math.sqrt(dirX*dirX + dirY*dirY); if (distToTarget > org.radius * 0.5) { targetVx = (dirX / distToTarget) * org.speed * org.wallAttractionFactor * WALL_ATTRACTION_FORCE; targetVy = (dirY / distToTarget) * org.speed * org.wallAttractionFactor * WALL_ATTRACTION_FORCE; } else { targetVx = 0; targetVy = 0;} } 
                else if (org.targetHerdCenter) { const dirX = org.targetHerdCenter.x - org.x; const dirY = org.targetHerdCenter.y - org.y; const distToTarget = Math.sqrt(dirX*dirX + dirY*dirY); if (distToTarget > org.radius * 2) { targetVx = (dirX / distToTarget) * org.speed * org.herdDrive * HERD_FORCE; targetVy = (dirY / distToTarget) * org.speed * org.herdDrive * HERD_FORCE; } }
                else if(!wantsToLeaveSalt&&org.speed>0){if(Math.random()<0.05){const angle=Math.random()*Math.PI*2;targetVx=Math.cos(angle)*org.speed*0.3;targetVy=Math.sin(angle)*org.speed*0.3;}}
                else if(org.speed===0&&!wantsToLeaveSalt){targetVx=0;targetVy=0;}
                
                const inertiaFactor=org.speed>0?0.05:1;org.vx+=(targetVx-org.vx)*inertiaFactor;org.vy+=(targetVy-org.vy)*inertiaFactor;
                if(org.speed===0&&!wantsToLeaveSalt){org.vx*=0.9;org.vy*=0.9;}
                else{const currentSpeedVal=Math.sqrt(org.vx**2+org.vy**2);if(currentSpeedVal>org.speed*1.5&&org.speed>0){org.vx=(org.vx/currentSpeedVal)*org.speed*1.5;org.vy=(org.vy/currentSpeedVal)*org.speed*1.5;}}
                
                org.x+=org.vx*deltaTime;org.y+=org.vy*deltaTime;
                
                walls.forEach(wall=>{const closestPoint=getClosestPointOnLineSegment(org.x,org.y,wall.x1,wall.y1,wall.x2,wall.y2);const dx=org.x-closestPoint.x;const dy=org.y-closestPoint.y;const distSq=dx*dx+dy*dy;const totalRadius=org.radius+wall.thickness/2;if(distSq<totalRadius*totalRadius){const dist=Math.sqrt(distSq);const overlap=totalRadius-dist;if(dist>0){const pushX=(dx/dist)*overlap;const pushY=(dy/dist)*overlap;org.x+=pushX;org.y+=pushY;const dotProduct=org.vx*(closestPoint.x-org.x)+org.vy*(closestPoint.y-org.y);if(dotProduct<0){org.vx*=-0.3;org.vy*=-0.3;}}else{org.x+=(Math.random()-0.5)*0.1;org.y+=(Math.random()-0.5)*0.1;}}});
                const bounceFactor=-0.5;if(org.x-org.radius<0){org.x=org.radius;org.vx*=bounceFactor;}else if(org.x+org.radius>worldWidth){org.x=worldWidth-org.radius;org.vx*=bounceFactor;} if(org.y-org.radius<0){org.y=org.radius;org.vy*=bounceFactor;}else if(org.y+org.radius>worldHeight){org.y=worldHeight-org.radius;org.vy*=bounceFactor;}
                organisms.forEach(other=>{if(org===other||deadOrConsumedOrganismIds.has(other.id)||other.isEgg)return;const dx=other.x-org.x;const dy=other.y-org.y;const distanceSq=dx*dx+dy*dy;const sumRadii=org.radius+other.radius;if(distanceSq<sumRadii*sumRadii&&distanceSq>0){const isEatingScenario=org.isHostile&&((org.strength>other.strength)||(org.strength===other.strength&&org.radius>other.radius));if(!isEatingScenario){const distance=Math.sqrt(distanceSq);const overlap=sumRadii-distance;const pushX=(dx/distance)*overlap*0.5;const pushY=(dy/distance)*overlap*0.5;org.x-=pushX;org.y-=pushY;other.x+=pushX;other.y+=pushY;const tempVx=org.vx;const tempVy=org.vy;org.vx=other.vx*0.5;org.vy=other.vy*0.5;other.vx=tempVx*0.5;other.vy=tempVy*0.5;}}});
                
                if(org.isHostile&&org.eatCooldown<=0){
                    organisms.forEach(other=>{
                        if(org===other||deadOrConsumedOrganismIds.has(other.id)||deadOrConsumedOrganismIds.has(org.id))return;
                        const dx=other.x-org.x;const dy=other.y-org.y;const distance=Math.sqrt(dx*dx+dy*dy);
                        if(distance<org.radius+other.radius){
                            let orgWins=false;
                            if (other.isEgg) { orgWins = true; } 
                            else { const isEdibleByMulticell=!(org.cellCount>1&&other.cellCount===1&&other.radius<MIN_RADIUS_TO_EAT_BY_MULTICELLULAR); if(JSON.stringify(org.genes)!==JSON.stringify(other.genes)&&isEdibleByMulticell){ if(org.strength>other.strength)orgWins=true; else if(org.strength===other.strength&&org.radius>other.radius)orgWins=true; } }
                            if(orgWins){
                                deadOrConsumedOrganismIds.add(other.id);
                                org.radius=Math.min(MAX_RADIUS_CAP,org.radius+other.radius*CONSUMPTION_SIZE_BOOST);
                                if (!other.isEgg) { org.genes[GENE_BASE_SIZE]=Math.min(1,(org.genes[GENE_BASE_SIZE]||0)+(other.genes[GENE_BASE_SIZE]||0)*CONSUMPTION_SIZE_BOOST*0.1); }
                                let lifespanGain=LIFESPAN_EXTENSION_PER_CONSUMED_CELL_SECONDS*(other.isEgg ? 1 : other.cellCount); 
                                if(currentSaltRegion){lifespanGain*=(1-(SALT_REGION_LIFESPAN_REDUCTION*(1-org.saltToleranceFactor)));} 
                                if (org.isEggLayer) lifespanGain *= EGG_LIFESPAN_FOOD_BONUS; 
                                org.timeToLive+=lifespanGain;
                                org.eatCooldown=EATING_COOLDOWN_SECONDS;
                                interpretGenes(org); 
                            }
                        }
                    });
                }
                else if(org.eatCooldown<=0){ 
                    husks.forEach(husk=>{
                        if(consumedHuskIds.has(husk.id))return;
                        const dx=husk.x-org.x;const dy=husk.y-org.y;const distance=Math.sqrt(dx*dx+dy*dy);
                        const canEatHusk = !org.isScavenger || (org.isScavenger && husk.radius <= org.radius);
                        if(distance<org.radius+husk.radius && canEatHusk){
                            consumedHuskIds.add(husk.id);
                            let lifespanGain=LIFESPAN_EXTENSION_FROM_HUSK*(husk.cellCount||1);
                            if(husk.isDispensed)lifespanGain*=0.5;
                            if(currentSaltRegion){lifespanGain*=(1-(SALT_REGION_LIFESPAN_REDUCTION*(1-org.saltToleranceFactor)));} 
                            if (org.isEggLayer) lifespanGain *= EGG_LIFESPAN_FOOD_BONUS; 
                            org.timeToLive+=lifespanGain;
                            org.eatCooldown=EATING_COOLDOWN_SECONDS;
                        }
                    });
                }
            });
            
            organisms=organisms.filter(org=>!deadOrConsumedOrganismIds.has(org.id));
            husks=husks.filter(husk=>!consumedHuskIds.has(husk.id));
            organisms.push(...newOrganisms);
            lastTickTime=currentTime;
            updateStats();
        }

        function getCellOffsets(numCells, baseOffsetScale, rotation = 0) { const offsets = []; const angleOffset = rotation; if (numCells <= 0) return [{x:0, y:0}]; if (numCells === 1) { offsets.push({ x: 0, y: 0 }); } else if (numCells === 2) { const d = baseOffsetScale * 0.7; offsets.push({ x: -d*Math.cos(angleOffset), y: -d*Math.sin(angleOffset) }); offsets.push({ x: d*Math.cos(angleOffset), y: d*Math.sin(angleOffset) }); } else if (numCells === 3) { const r = baseOffsetScale * 0.9; for (let i=0; i<3; i++) offsets.push({ x: r*Math.cos(i*2*Math.PI/3 + angleOffset), y: r*Math.sin(i*2*Math.PI/3 + angleOffset) }); } else if (numCells === 4) { const d = baseOffsetScale * 1.0; const ba=[Math.PI/4, 3*Math.PI/4, 5*Math.PI/4, 7*Math.PI/4]; for (let i=0; i<4; i++) offsets.push({ x: d*Math.cos(ba[i]+angleOffset), y: d*Math.sin(ba[i]+angleOffset) }); } else { offsets.push({ x: 0, y: 0 }); const noc = numCells - 1; if (noc > 0) { const as = (Math.PI*2)/noc; let rrf=1.5; if (noc>12) rrf=1.8; if (noc>24) rrf=2.2; let rr=baseOffsetScale*rrf; rr=Math.max(rr, (noc*baseOffsetScale*0.35)/Math.PI); for (let i=0; i<noc; i++) offsets.push({x:rr*Math.cos(i*as+angleOffset), y:rr*Math.sin(i*as+angleOffset)});}} return offsets; }
        
        function draw() { ctx.clearRect(0,0,canvas.width,canvas.height); ctx.save(); ctx.scale(viewScale,viewScale); ctx.translate(-viewOffsetX,-viewOffsetY); ctx.fillStyle=SALT_REGION_TINT_COLOR; saltRegions.forEach(region=>{ctx.fillRect(region.x,region.y,region.width,region.height);}); ctx.strokeStyle='#555e70'; ctx.lineWidth=WALL_THICKNESS; walls.forEach(wall=>{ctx.beginPath();ctx.moveTo(wall.x1,wall.y1);ctx.lineTo(wall.x2,wall.y2);ctx.stroke();}); ctx.fillStyle='#4a5568'; foodDispensers.forEach(dispenser=>{ctx.beginPath();ctx.arc(dispenser.x,dispenser.y,dispenser.radius,0,Math.PI*2);ctx.fill();}); if(showScavengerHeatmap){ctx.fillStyle=HEATMAP_SCAVENGER_COLOR;organisms.forEach(org=>{if(org.isScavenger && !org.isEgg){ctx.beginPath();ctx.arc(org.x,org.y,org.radius*HEATMAP_RADIUS_MULTIPLIER,0,Math.PI*2);ctx.fill();}}); } if(showPreyHeatmap){ctx.fillStyle=HEATMAP_PREY_COLOR;organisms.forEach(org=>{if(org.flees && !org.isEgg){ctx.beginPath();ctx.arc(org.x,org.y,org.radius*HEATMAP_RADIUS_MULTIPLIER,0,Math.PI*2);ctx.fill();}}); } if(showPredatorHeatmap){ctx.fillStyle=HEATMAP_PREDATOR_COLOR;organisms.forEach(org=>{if(org.isHostile && !org.isEgg){ctx.beginPath();ctx.arc(org.x,org.y,org.radius*HEATMAP_RADIUS_MULTIPLIER,0,Math.PI*2);ctx.fill();}}); } husks.forEach(husk=>{ctx.beginPath();ctx.arc(husk.x,husk.y,husk.radius,0,Math.PI*2);ctx.fillStyle=HUSK_COLOR;ctx.fill();}); organisms.forEach(org=>{ if (org.isPlasmodiumActive && org.plasmodiumEffectRadius > 0 && !org.isEgg) { ctx.fillStyle = `hsla(${Math.floor((org.genes[GENE_HUE] || 0) * 360)}, 70%, 60%, ${PLASMODIUM_TINT_ALPHA})`; ctx.beginPath(); ctx.arc(org.x, org.y, org.plasmodiumEffectRadius, 0, Math.PI * 2); ctx.fill(); } let fillStyle = org.color; if (org.isEgg) { fillStyle = EGG_COLOR; } else if (org.isHostile) { fillStyle = `hsl(${Math.floor((org.genes[GENE_HUE]||0)*360)}, 90%, 45%)`; } ctx.fillStyle = fillStyle; if(!org.cellCount||org.cellCount<=0||org.isEgg){ ctx.beginPath();ctx.arc(org.x,org.y,org.radius,0,Math.PI*2);ctx.fill(); } else{ const numCells=org.cellCount; const individualCellRadius=Math.max(1.5,org.radius/(Math.sqrt(numCells)*0.8+0.2)); const cellLayoutScale=individualCellRadius*0.7; const uniqueAngleOffset=(org.id.charCodeAt(0)%16/16)*Math.PI*2; const cellPositions=getCellOffsets(numCells,cellLayoutScale,uniqueAngleOffset); cellPositions.forEach(pos=>{ctx.beginPath();ctx.arc(org.x+pos.x,org.y+pos.y,individualCellRadius,0,Math.PI*2);ctx.fill();}); } if(!org.isEgg) { if(org.flagellaCount>0){ctx.strokeStyle=org.color;ctx.lineWidth=Math.max(1,org.radius*0.1);const angleStep=(Math.PI*2)/org.flagellaCount;for(let i=0;i<org.flagellaCount;i++){const baseAngle=i*angleStep;const wave=Math.sin(simulationTime*10/gameSpeedMultiplier+baseAngle+org.id.charCodeAt(0)*0.1)*0.4;const angle=Math.atan2(org.vy,org.vx)+Math.PI+baseAngle+wave;const length=org.radius*1.2;ctx.beginPath();ctx.moveTo(org.x,org.y);ctx.lineTo(org.x+Math.cos(angle)*length,org.y+Math.sin(angle)*length);ctx.stroke();}} if(org.sightRange>0){ctx.fillStyle='rgba(255,255,255,0.8)';const eyeSize=Math.max(1.5,org.radius*0.25);const moveAngle=Math.atan2(org.vy,org.vx);ctx.beginPath();ctx.arc(org.x+Math.cos(moveAngle)*org.radius*0.5,org.y+Math.sin(moveAngle)*org.radius*0.5,eyeSize,0,Math.PI*2);ctx.fill();}} }); ctx.restore(); }

        function gameLoop(timestamp) { update(timestamp||performance.now());draw();if(!isPaused){animationFrameId=requestAnimationFrame(gameLoop);}}
        
        function updateHeatmapButtonStates() {
            toggleScavengerHeatmapButton.classList.toggle('heatmap-button-active', showScavengerHeatmap);
            togglePreyHeatmapButton.classList.toggle('heatmap-button-active', showPreyHeatmap);
            togglePredatorHeatmapButton.classList.toggle('heatmap-button-active', showPredatorHeatmap);
        }
        
        // Event Listeners
        window.addEventListener('resize',resizeCanvas);
        resetButton.addEventListener('click',initSimulation);
        pauseButton.addEventListener('click',()=>{isPaused=!isPaused;pauseButton.textContent=isPaused?"Resume":"Pause";if(!isPaused){lastTickTime=performance.now();if(animationFrameId)cancelAnimationFrame(animationFrameId);animationFrameId=requestAnimationFrame(gameLoop);}else{if(animationFrameId)cancelAnimationFrame(animationFrameId);}});
        
        if(speedSlider){speedSlider.addEventListener('input',()=>{gameSpeedMultiplier=parseFloat(speedSlider.value);speedValueEl.textContent=`${gameSpeedMultiplier.toFixed(1)}x`;});}
        if(maxOrganismsSlider){maxOrganismsSlider.addEventListener('input',()=>{maxOrganismsLimit=parseInt(maxOrganismsSlider.value);maxOrganismsValueEl.textContent=maxOrganismsLimit;});}

        toggleScavengerHeatmapButton.addEventListener('click',()=>{showScavengerHeatmap=!showScavengerHeatmap;updateHeatmapButtonStates();if(isPaused)draw();});
        togglePreyHeatmapButton.addEventListener('click',()=>{showPreyHeatmap=!showPreyHeatmap;updateHeatmapButtonStates();if(isPaused)draw();});
        togglePredatorHeatmapButton.addEventListener('click',()=>{showPredatorHeatmap=!showPredatorHeatmap;updateHeatmapButtonStates();if(isPaused)draw();});
        
        canvas.addEventListener('click',(event)=>{
            const worldCoords=screenToWorld(event.clientX,event.clientY);
            let organismClicked=false;
            for(let i=organisms.length-1;i>=0;i--){ // Iterate backwards to click top-most organism
                const org=organisms[i];
                const dx=worldCoords.x-org.x;
                const dy=worldCoords.y-org.y;
                if(dx*dx+dy*dy<org.radius*org.radius){
                    organismClicked=true;
                    infoOrganismIdEl.textContent=`Organism ID: ${org.id} (Cells: ${org.cellCount})${org.isEgg ? ' - EGG' : ''}`;
                    infoGeneListEl.innerHTML='';
                    org.genes.forEach((geneVal,index)=>{
                        const geneEl=document.createElement('p');
                        let geneDisplayVal=geneVal.toFixed(3);
                        if(index===GENE_COMPLEXITY) geneDisplayVal=geneVal.toFixed(geneVal>10?1:3); // More precision for small complexity

                        let valueClass = 'gene-neutral'; // Default for value-based genes
                        if (GENE_THRESHOLDS.hasOwnProperty(index)) {
                            const threshold = GENE_THRESHOLDS[index];
                            if (geneVal >= threshold) {
                                valueClass = 'gene-active';
                            } else {
                                valueClass = 'gene-inactive';
                            }
                        }
                        
                        geneEl.innerHTML=`<span class="font-medium text-gray-400">${GENE_NAMES[index]||'Unknown Gene'}:</span> <span class="${valueClass}">${geneDisplayVal}</span>`;
                        infoGeneListEl.appendChild(geneEl);
                    });
                    organismInfoModal.classList.remove('hidden');
                    if(!isPaused && !organismInfoModal.classList.contains('hidden')){
                        isPaused=true;
                        pauseButton.textContent="Resume";
                        if(animationFrameId)cancelAnimationFrame(animationFrameId);
                    }
                    break; 
                }
            } 
            if(!organismClicked){ // If no organism clicked, add a husk
                husks.push({id:'husk_manual_'+Date.now()+'_'+Math.random(),x:worldCoords.x,y:worldCoords.y,radius:HUSK_DEFAULT_RADIUS, cellCount: 1});
            }
        }); 
        
        canvas.addEventListener('wheel',(event)=>{event.preventDefault();const rect=canvas.getBoundingClientRect();const mouseCanvasX=event.clientX-rect.left;const mouseCanvasY=event.clientY-rect.top;const worldMouseXBeforeZoom=(mouseCanvasX/viewScale)+viewOffsetX;const worldMouseYBeforeZoom=(mouseCanvasY/viewScale)+viewOffsetY;const zoomIntensity=0.1;const direction=event.deltaY<0?1:-1;viewScale*=(1+direction*zoomIntensity);clampViewOffset();viewOffsetX=worldMouseXBeforeZoom-(mouseCanvasX/viewScale);viewOffsetY=worldMouseYBeforeZoom-(mouseCanvasY/viewScale);clampViewOffset();if(!isPaused||isPaused)draw();});
        
        function closeModalAndResume(){
            organismInfoModal.classList.add('hidden');
            // Only resume if it was paused *by opening the modal*
            if(isPaused && pauseButton.textContent==="Resume" && organismInfoModal.classList.contains('hidden')){ 
                isPaused=false;
                pauseButton.textContent="Pause";
                lastTickTime=performance.now();
                if(animationFrameId)cancelAnimationFrame(animationFrameId);
                animationFrameId=requestAnimationFrame(gameLoop);
            }
        }
        closeInfoModal.addEventListener('click',closeModalAndResume);
        closeInfoModalButton.addEventListener('click',closeModalAndResume);
        organismInfoModal.addEventListener('click',(event)=>{if(event.target===organismInfoModal)closeModalAndResume();});

        // Initial Setup
        resizeCanvas(); 
        initSimulation(); 
    </script>
</body>
</html>