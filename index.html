<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolution Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; overflow: hidden; background-color: #111827; color: #e5e7eb; }
        #simulationCanvas {
            display: block;
            background-color: #1f2937; /* Tailwind gray-800 */
            border: 1px solid #374151; /* Tailwind gray-700 */
        }
        #controls {
            background-color: #374151; /* Tailwind gray-700 */
        }
        .stat-label { color: #9ca3af; /* Tailwind gray-400 */ }
        .stat-value { color: #e5e7eb; /* Tailwind gray-200 */ }
        .modal-backdrop { background-color: rgba(0, 0, 0, 0.5); }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            background: #2563eb; cursor: pointer; border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px; background: #2563eb; cursor: pointer;
            border-radius: 50%; border: none;
        }
        .heatmap-button-active { background-color: #10b981; /* Tailwind green-500 */ }
        .heatmap-button-active:hover { background-color: #059669; /* Tailwind green-600 */ }
        .gene-active { color: #4ade80; /* Tailwind green-400 */ }
        .gene-inactive { color: #f87171; /* Tailwind red-400 */ }
        .gene-neutral { color: #cbd5e1; /* Tailwind slate-300 */ }
    </style>
</head>
<body class="flex flex-col h-screen">

    <div id="controls" class="p-4 border-b border-gray-600">
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
            <div><span class="stat-label">Organisms:</span> <span id="organismCount" class="stat-value font-semibold">0</span></div>
            <div><span class="stat-label">Elapsed Time (s):</span> <span id="elapsedTime" class="stat-value font-semibold">0</span></div>
            <div><span class="stat-label">Duplications:</span> <span id="duplicationCount" class="stat-value font-semibold">0</span></div>
            <div><span class="stat-label">Evolutions:</span> <span id="evolutionCount" class="stat-value font-semibold">0</span></div>
        </div>
        <div class="mt-3">
             <button id="resetButton" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg text-sm font-medium">Reset Simulation</button>
             <button id="pauseButton" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium ml-2">Pause</button>
             <button id="howToPlayButton" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-medium ml-2">How to Play</button>
        </div>
        <div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2">
            <div class="flex items-center space-x-2">
                <label for="speedSlider" class="text-sm stat-label whitespace-nowrap">Speed:</label>
                <input type="range" id="speedSlider" min="1" max="16" value="1" step="1" class="w-full accent-blue-600 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                <span id="speedValue" class="text-sm stat-value font-semibold w-12 text-right">1.0x</span>
            </div>
            <div class="flex items-center space-x-2">
                <label for="maxOrganismsSlider" class="text-sm stat-label whitespace-nowrap">Max Orgs:</label>
                <input type="range" id="maxOrganismsSlider" min="200" max="2000" value="900" step="50" class="w-full accent-blue-600 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                <span id="maxOrganismsValue" class="text-sm stat-value font-semibold w-16 text-right">900</span>
            </div>
        </div>
        <div class="mt-3 flex flex-wrap gap-2 items-center">
            <button id="toggleScavengerHeatmap" class="px-3 py-1 rounded-md text-xs font-medium text-white transition-colors bg-sky-600 hover:bg-sky-700">Scavenger Heatmap</button>
            <button id="togglePreyHeatmap" class="px-3 py-1 rounded-md text-xs font-medium text-white transition-colors bg-sky-600 hover:bg-sky-700">Prey (Fear) Heatmap</button>
            <button id="togglePredatorHeatmap" class="px-3 py-1 rounded-md text-xs font-medium text-white transition-colors bg-sky-600 hover:bg-sky-700">Predator Heatmap</button>
        </div>
    </div>

    <div class="flex-grow relative">
        <canvas id="simulationCanvas"></canvas>
    </div>

    <div id="organismInfoModal" class="fixed inset-0 modal-backdrop flex items-center justify-center hidden p-4 z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-gray-200 max-w-md w-full max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold" id="infoOrganismId">Organism Details</h3>
                <button id="closeInfoModal" class="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
            </div>
            <div id="infoGeneList" class="space-y-1 text-sm mb-4"></div>
            <div class="text-xs text-gray-400 mb-3">
                <p><span class="gene-active">Green:</span> Trait active / threshold met.</p>
                <p><span class="gene-inactive">Red:</span> Trait inactive / threshold not met.</p>
                <p><span class="gene-neutral">Slate:</span> Value-based gene (e.g., size, color).</p>
            </div>
            <button id="closeInfoModalButton" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">Close</button>
        </div>
    </div>

    <div id="howToPlayModal" class="fixed inset-0 modal-backdrop flex items-center justify-center hidden p-4 z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-gray-200 max-w-lg w-full max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold">How to Play</h3>
                <button id="closeHowToPlayModal" class="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
            </div>
            <div class="text-sm space-y-3">
                <p>Welcome to the Evolution Simulator! Observe and interact with simple organisms as they evolve and adapt in a dynamic environment.</p>
                
                <h4 class="font-semibold text-base mt-4">Simulation Basics:</h4>
                <ul class="list-disc list-inside space-y-1 ml-2">
                    <li>Organisms move, duplicate, and interact with each other and the environment.</li>
                    <li>They have a lifespan that decreases over time. Eating food (husks) extends their life.</li>
                    <li>Duplication can lead to genetic mutations, driving evolution.</li>
                    <li>Walls act as obstacles, food dispensers provide husks, and salt regions can affect organisms.</li>
                </ul>

                <h4 class="font-semibold text-base mt-4">Interaction:</h4>
                <ul class="list-disc list-inside space-y-1 ml-2">
                    <li><strong>Click on an organism:</strong> Opens a detailed panel showing its genes and current traits. The simulation will pause when this modal is open.</li>
                    <li><strong>Click on empty space:</strong> Adds a new husk (food source) at that location.</li>
                    <li><strong>Mouse Wheel:</strong> Zoom in and out of the simulation view.</li>
                    <li><strong>Drag Canvas:</strong> (Currently not implemented, but would be here if it was)</li>
                    <li><strong>Sliders:</strong> Adjust simulation speed and the maximum number of organisms.</li>
                    <li><strong>Heatmap Buttons:</strong> Toggle visual heatmaps for scavenger, prey, and predator activity.</li>
                </ul>

                <h4 class="font-semibold text-base mt-4">Gene Definitions:</h4>
                <ul class="list-disc list-inside space-y-1 ml-2">
                    <li><strong>Hue:</strong> Determines the organism's color.</li>
                    <li><strong>Base Size:</strong> Influences the organism's fundamental size.</li>
                    <li><strong>Dup.Rate (Duplication Rate):</strong> Affects how frequently an organism attempts to duplicate.</li>
                    <li><strong>Flagella:</strong> The number of flagella an organism has, increasing its speed.</li>
                    <li><strong>Hostility:</strong> Determines if an organism is a predator (hunts other organisms).</li>
                    <li><strong>Sight Range:</strong> How far an organism can "see" other organisms or food.</li>
                    <li><strong>Fear:</strong> Influences how strongly an organism flees from threats.</li>
                    <li><strong>Predator:</strong> The drive to actively seek and consume other organisms.</li>
                    <li><strong>Complexity:</strong> Affects the number of individual cells an organism is composed of, and its strength.</li>
                    <li><strong>Scavenger:</strong> Determines if an organism prefers to eat husks (dead organisms/food).</li>
                    <li><strong>Salt Tolerance:</strong> Reduces the negative effects of salt regions.</li>
                    <li><strong>Salt Avoidance:</strong> Causes the organism to actively move away from salt regions.</li>
                    <li><strong>Plasmodium:</strong> Enables a larger, more influential "plasmodium" effect radius.</li>
                    <li><strong>Wall Attract:</strong> Causes the organism to be attracted to nearby walls.</li>
                    <li><strong>Herd Mental (Herd Mentality):</strong> Causes the organism to seek out and stay near other herd-mentality organisms.</li>
                    <li><strong>Egg Layer:</strong> Enables the organism to lay eggs which hatch after a duration.</li>
                    <li><strong>Dwelling:</strong> Causes the organism to return to its birth location when well-fed.</li>
                    <li><strong>Mycelium:</strong> Enables the organism to form a network with nearby mycelium organisms, sharing resources.</li>
                    <li><strong>Pathfinding:</strong> Allows the organism to navigate around walls more effectively when pursuing targets or fleeing.</li>
                    <li><strong>Starvation:</strong> When active, causes the organism to ignore fear and salt avoidance when its lifespan is critically low, prioritizing food.</li>
                </ul>
            </div>
            <button id="closeHowToPlayModalButton" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg mt-6">Got It!</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        const organismCountEl = document.getElementById('organismCount');
        const elapsedTimeEl = document.getElementById('elapsedTime');
        const duplicationCountEl = document.getElementById('duplicationCount');
        const evolutionCountEl = document.getElementById('evolutionCount');
        const resetButton = document.getElementById('resetButton');
        const pauseButton = document.getElementById('pauseButton');
        const howToPlayButton = document.getElementById('howToPlayButton'); // New button
        const organismInfoModal = document.getElementById('organismInfoModal');
        const infoOrganismIdEl = document.getElementById('infoOrganismId');
        const infoGeneListEl = document.getElementById('infoGeneList');
        const closeInfoModal = document.getElementById('closeInfoModal');
        const closeInfoModalButton = document.getElementById('closeInfoModalButton');
        const howToPlayModal = document.getElementById('howToPlayModal'); // New modal
        const closeHowToPlayModal = document.getElementById('closeHowToPlayModal'); // New close button
        const closeHowToPlayModalButton = document.getElementById('closeHowToPlayModalButton'); // New close button
        const speedSlider = document.getElementById('speedSlider');
        const speedValueEl = document.getElementById('speedValue');
        const maxOrganismsSlider = document.getElementById('maxOrganismsSlider'); // New slider
        const maxOrganismsValueEl = document.getElementById('maxOrganismsValue'); // New slider value display
        const toggleScavengerHeatmapButton = document.getElementById('toggleScavengerHeatmap');
        const togglePreyHeatmapButton = document.getElementById('togglePreyHeatmap');
        const togglePredatorHeatmapButton = document.getElementById('togglePredatorHeatmap');

        // Simulation Parameters
        const DUPLICATION_CHANCE_PER_SECOND = 0.012;
        const EVOLUTION_CHANCE_ON_DUPLICATION = 0.025;
        const GENE_MUTATION_STRENGTH = 0.5;
        const MINOR_HUE_SHIFT_STRENGTH = 0.4;
        // MAX_GENES updated to include new genes
        const MAX_GENES = 20; // Increased for new Starvation gene
        const INITIAL_GENE_COUNT = MAX_GENES; // Should match MAX_GENES
        const BASE_SPEED = 0.001;
        const FLAGELLA_SPEED_BONUS = 25; // Speed bonus per effective flagella unit
        const HOSTILITY_THRESHOLD = 0.5;
        const FEAR_FACTOR_THRESHOLD = 0.3;
        const PREDATOR_DRIVE_THRESHOLD = 0.3;
        const SCAVENGER_THRESHOLD = 0.3;
        const CONSUMPTION_SIZE_BOOST = 0.3;
        const MAX_RADIUS_CAP = 600;
        const LIFESPAN_PER_CELLCOUNT_SECONDS = 180;
        const LIFESPAN_EXTENSION_PER_CONSUMED_CELL_SECONDS = 45;
        const LIFESPAN_EXTENSION_FROM_HUSK = 45;
        const MAX_NEARBY_CELLS_FOR_DUPLICATION = 5;
        const CROWDING_CHECK_RADIUS = 22;
        const HUSK_COLOR = 'rgba(220, 220, 220, 0.7)';
        const HUSK_DEFAULT_RADIUS = 3;
        const EATING_COOLDOWN_SECONDS = 6;
        const MIN_RADIUS_TO_EAT_BY_MULTICELLULAR = HUSK_DEFAULT_RADIUS;

        // Environment Parameters
        const NUM_CAVE_WALLS = 190;
        const MIN_WALL_LENGTH = 35;
        const MAX_WALL_LENGTH = 100;
        const WALL_THICKNESS = 20;
        const WALL_CONNECTION_PROBABILITY = 40/41;
        const MIN_VERTEX_ANGLE_DEG = 110;
        const MIN_DEFLECTION_FROM_STRAIGHT_DEG = 5;
        const NUM_FOOD_DISPENSERS = 3;
        const FOOD_DISPENSER_RATE_SECONDS = 6;
        const FOOD_DISPENSER_HUSK_SPEED = 30;
        const NUM_SALT_REGIONS = 1;
        const SALT_REGION_LIFESPAN_REDUCTION = 0.3;
        const SALT_REGION_MUTATION_BOOST = 0.3;
        const SALT_REGION_TINT_COLOR = 'rgba(255, 255, 95, 0.07)';

        // Plasmodium Parameters
        const PLASMODIUM_EXPRESSION_THRESHOLD = 0.7;
        // Plasmodium radius: 2x at threshold, 7x at max (1.0)
        const PLASMODIUM_RADIUS_AT_THRESHOLD_MULTIPLIER = 2.0;
        const PLASMODIUM_RADIUS_AT_MAX_MULTIPLIER = 7.0;
        const PLASMODIUM_TINT_ALPHA = 0.15;

        // Heatmap Parameters
        const HEATMAP_ALPHA = 0.08;
        const HEATMAP_RADIUS_MULTIPLIER = 5;
        const HEATMAP_SCAVENGER_COLOR = `rgba(255, 215, 0, ${HEATMAP_ALPHA})`; // Gold
        const HEATMAP_PREY_COLOR = `rgba(65, 105, 225, ${HEATMAP_ALPHA})`;    // Royal Blue
        const HEATMAP_PREDATOR_COLOR = `rgba(220, 20, 60, ${HEATMAP_ALPHA})`;  // Crimson

        // Existing New Gene Parameters
        const WALL_ATTRACTION_THRESHOLD = 0.7;
        const WALL_ATTRACTION_FORCE = 0.05;
        const HERD_MENTALITY_THRESHOLD = 0.45;
        const HERD_DETECTION_RADIUS_MULTIPLIER = 1.5;
        const HERD_FORCE = 0.03;
        const EGG_LAYING_THRESHOLD = 0.6;
        const EGG_DURATION_SECONDS = 140;
        const EGG_LIFESPAN_FOOD_BONUS = 1.5;
        const EGG_COLOR = 'rgba(255, 255, 255, 0.9)';
        const EGG_STRENGTH = 0.01;

        // Dwelling Gene Parameters
        const DWELLING_GENE_THRESHOLD = 0.6;
        const DWELLING_LIFESPAN_SATISFACTION_RATIO = 0.75;
        const DWELLING_FORCE = 0.04;
        const DWELLING_REACH_THRESHOLD = 10;

        // NEW GENE PARAMETERS
        const MYCELIUM_THRESHOLD = 0.65; // Gene value above this enables mycelium behavior
        const PATHFINDING_THRESHOLD = 0.7; // Gene value above this enables pathfinding behavior
        const WALL_AVOIDANCE_FORCE = 0.08; // How strongly to avoid walls when fleeing
        const WALL_STEERING_FORCE = 0.06; // How strongly to steer around walls when hunting/scavenging
        const WALL_DETECTION_RANGE_MULTIPLIER = 2.5; // Multiplier of organism radius for wall detection
        const STARVATION_THRESHOLD_LIFESPAN = 20; // Lifespan remaining below which starvation kicks in
        const STARVATION_GENE_ACTIVATION_THRESHOLD = 0.3; // Gene value above this enables starvation override
        const DRAG_FACTOR = 0.95; // Multiplier for velocity to simulate drag (0.95 means 5% velocity loss per tick)


        // Gene Indices & Names
        const GENE_HUE = 0; const GENE_BASE_SIZE = 1; const GENE_DUP_RATE = 2;
        const GENE_FLAGELLA = 3; const GENE_HOSTILITY = 4; const GENE_SIGHT_RANGE = 5;
        const GENE_FEAR_FACTOR = 6; const GENE_PREDATOR_DRIVE = 7; const GENE_COMPLEXITY = 8;
        const GENE_SCAVENGER = 9; const GENE_SALT_TOLERANCE = 10; const GENE_SALT_AVOIDANCE = 11;
        const GENE_PLASMODIUM = 12; const GENE_WALL_ATTRACTION = 13;
        const GENE_HERD_MENTALITY = 14; const GENE_EGG_LAYING = 15;
        const GENE_DWELLING = 16;
        const GENE_MYCELIUM = 17;
        const GENE_PATHFINDING = 18;
        const GENE_STARVATION = 19; // New gene index

        const GENE_NAMES = [
            "Hue", "BaseSize", "Dup.Rate", "Flagella", "Hostility", "SightRange",
            "Fear", "Predator", "Complexity", "Scavenger", "SaltTolerance", "SaltAvoidance",
            "Plasmodium", "WallAttract", "HerdMental", "EggLayer", "Dwelling",
            "Mycelium", "Pathfinding", "Starvation" // New gene name
        ];

        // Gene Thresholds for Modal Display
        const GENE_THRESHOLDS = {
            [GENE_HOSTILITY]: HOSTILITY_THRESHOLD,
            [GENE_FEAR_FACTOR]: FEAR_FACTOR_THRESHOLD,
            [GENE_PREDATOR_DRIVE]: PREDATOR_DRIVE_THRESHOLD,
            [GENE_SCAVENGER]: SCAVENGER_THRESHOLD,
            [GENE_SALT_AVOIDANCE]: 0.5, // Behavior activates if gene > 0.5
            [GENE_PLASMODIUM]: PLASMODIUM_EXPRESSION_THRESHOLD,
            [GENE_WALL_ATTRACTION]: WALL_ATTRACTION_THRESHOLD,
            [GENE_HERD_MENTALITY]: HERD_MENTALITY_THRESHOLD,
            [GENE_EGG_LAYING]: EGG_LAYING_THRESHOLD,
            [GENE_DWELLING]: DWELLING_GENE_THRESHOLD,
            [GENE_FLAGELLA]: 0.01, // Special case: considered "active" if > 0.01 for speed bonus
            // NEW GENE THRESHOLDS
            [GENE_MYCELIUM]: MYCELIUM_THRESHOLD,
            [GENE_PATHFINDING]: PATHFINDING_THRESHOLD,
            [GENE_STARVATION]: STARVATION_GENE_ACTIVATION_THRESHOLD // Threshold for display
        };


        // Simulation State
        let organisms = [];
        let husks = [];
        let walls = [];
        let foodDispensers = [];
        let saltRegions = [];
        let simulationTime = 0;
        let lastTickTime = 0;
        let totalDuplications = 0;
        let totalEvolutions = 0;
        let isPaused = false;
        let animationFrameId;
        let gameSpeedMultiplier = 1.0;
        let maxOrganismsLimit = 900; // New: Max organism limit, default 900
        let showScavengerHeatmap = true; // Default ON
        let showPreyHeatmap = true;     // Default ON
        let showPredatorHeatmap = true;  // Default ON
        let viewScale = 1.0;
        let viewOffsetX = 0;
        let viewOffsetY = 0;
        let worldWidth, worldHeight;
        let myceliumConnections = new Set(); // Stores stringified pairs like "id1-id2" for drawing

        function resizeCanvas() {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            if (!worldWidth || !worldHeight) {
                 worldWidth = canvas.width * 1.5; // Initial world size relative to canvas
                 worldHeight = canvas.height * 1.5;
            }
            clampViewOffset();
        }

        function calculateCellCount(genes) {
            return Math.max(1, Math.floor(1 + (genes[GENE_COMPLEXITY] || 0) * 4));
        }
        
        function createOrganism(x, y, genesOverride, parentBirthX, parentBirthY) {
            // Default genes are now of MAX_GENES length
            const defaultGenes = Array(MAX_GENES).fill(0).map(() => Math.random() * 0.3 + 0.1);
            const newGenes = genesOverride ? [...genesOverride] : defaultGenes;
            // Ensure newGenes array has MAX_GENES length, filling with random if shorter
            while (newGenes.length < MAX_GENES) { newGenes.push(Math.random() * 0.3 + 0.1); }
            
            const organism = {
                id: Math.random().toString(36).substr(2, 9), 
                x, y, 
                birthX: parentBirthX !== undefined ? parentBirthX : x,
                birthY: parentBirthY !== undefined ? parentBirthY : y,
                genes: newGenes,
                radius: 5, color: 'hsl(0, 100%, 50%)', actualDuplicationChance: DUPLICATION_CHANCE_PER_SECOND,
                speed: BASE_SPEED, flagellaCount: 0, isHostile: false, sightRange: 0,
                flees: false, hunts: false, isScavenging: false, 
                targetOrganism: null, targetHusk: null, targetWallPoint: null, targetHerdCenter: null, targetDwellingPoint: null,
                targetPoint: null, // NEW: Unified target point for movement calculations
                strength: 0, vx: (Math.random() - 0.5) * 0.1, vy: (Math.random() - 0.5) * 0.1, 
                age: 0, cellCount: 1, timeToLive: LIFESPAN_PER_CELLCOUNT_SECONDS, initialTimeToLive: LIFESPAN_PER_CELLCOUNT_SECONDS,
                eatCooldown: 0, 
                avoidsSalt: false, 
                isPlasmodiumActive: false, plasmodiumEffectRadius: 0, plasmodiumTargetHusk: null,
                isAttractedToWalls: false, wallAttractionFactor: 0,
                seeksHerd: false, herdDrive: 0,
                isEggLayer: false, isEgg: false, eggTimer: 0,
                canDwelling: false, isDwelling: false, dwellingGeneValue: 0,
                // New gene properties
                isMyceliumActive: false,
                canPathfind: false,
            };
            organism.cellCount = calculateCellCount(organism.genes);
            organism.initialTimeToLive = LIFESPAN_PER_CELLCOUNT_SECONDS * organism.cellCount;
            organism.timeToLive = organism.initialTimeToLive;
            return organism;
        }
        
        function interpretGenes(organism) {
            const g = organism.genes;
            if (organism.isEgg) {
                organism.color = EGG_COLOR;
                organism.speed = 0;
                organism.flagellaCount = 0;
                organism.isHostile = false; 
                organism.sightRange = 0;
                organism.strength = EGG_STRENGTH; 
                organism.isScavenger = false;
                organism.isAttractedToWalls = false;
                organism.seeksHerd = false;
                organism.isPlasmodiumActive = false; 
                organism.plasmodiumEffectRadius = 0;
                organism.canDwelling = false;
                organism.isDwelling = false;
                // New gene properties for eggs
                organism.isMyceliumActive = false;
                organism.canPathfind = false;
                return; 
            }

            organism.color = `hsl(${Math.floor((g[GENE_HUE] || 0) * 360)}, 70%, 60%)`;
            organism.cellCount = calculateCellCount(g);
            const minRadius = 3; const maxRadiusForGene = 8;
            let baseRadius = minRadius + ((g[GENE_BASE_SIZE] || 0) * (maxRadiusForGene - minRadius));
            const complexityFactor = 1 + (g[GENE_COMPLEXITY] || 0) * 1;
            organism.radius = baseRadius * complexityFactor;
            organism.radius = Math.min(organism.radius, MAX_RADIUS_CAP);
            const dupRateGene = g[GENE_DUP_RATE] === undefined ? 0.5 : g[GENE_DUP_RATE];
            organism.actualDuplicationChance = DUPLICATION_CHANCE_PER_SECOND * (0.5 + dupRateGene);
            
            const rawFlagellaValue = g[GENE_FLAGELLA] || 0;
            organism.flagellaCount = Math.floor(rawFlagellaValue * 3); 
            if (rawFlagellaValue > 0.01) { 
                const effectiveFlagellaForSpeed = Math.max(1, organism.flagellaCount); 
                organism.speed = BASE_SPEED + effectiveFlagellaForSpeed * FLAGELLA_SPEED_BONUS;
            } else {
                organism.speed = BASE_SPEED;
            }
            
            organism.isHostile = (g[GENE_HOSTILITY] || 0) > HOSTILITY_THRESHOLD;
            organism.sightRange = (g[GENE_SIGHT_RANGE] || 0) * 150;
            organism.strength = organism.cellCount; 
            organism.isScavenger = !organism.isHostile && (g[GENE_SCAVENGER] || 0) > SCAVENGER_THRESHOLD && organism.sightRange > 0;
            organism.saltToleranceFactor = g[GENE_SALT_TOLERANCE] || 0; 
            organism.avoidsSalt = (g[GENE_SALT_AVOIDANCE] || 0) > 0.5;
            organism.isPlasmodiumActive = (g[GENE_PLASMODIUM] || 0) >= PLASMODIUM_EXPRESSION_THRESHOLD;
            if (organism.isPlasmodiumActive) {
                const plasmodiumGeneValue = g[GENE_PLASMODIUM] || 0;
                let radiusMultiplier;
                if (plasmodiumGeneValue >= PLASMODIUM_EXPRESSION_THRESHOLD) {
                    // Linear interpolation between threshold and max value (1.0)
                    const range = 1.0 - PLASMODIUM_EXPRESSION_THRESHOLD;
                    const scaledValue = (plasmodiumGeneValue - PLASMODIUM_EXPRESSION_THRESHOLD) / range;
                    radiusMultiplier = PLASMODIUM_RADIUS_AT_THRESHOLD_MULTIPLIER + 
                                       (PLASMODIUM_RADIUS_AT_MAX_MULTIPLIER - PLASMODIUM_RADIUS_AT_THRESHOLD_MULTIPLIER) * scaledValue;
                } else {
                    radiusMultiplier = 0; // Should not be active below threshold
                }
                organism.plasmodiumEffectRadius = organism.radius * radiusMultiplier;
            } else {
                organism.plasmodiumEffectRadius = 0;
            }

            organism.wallAttractionFactor = g[GENE_WALL_ATTRACTION] || 0;
            organism.isAttractedToWalls = organism.wallAttractionFactor > WALL_ATTRACTION_THRESHOLD;
            
            organism.herdDrive = g[GENE_HERD_MENTALITY] || 0;
            organism.seeksHerd = organism.herdDrive > HERD_MENTALITY_THRESHOLD;

            organism.isEggLayer = (g[GENE_EGG_LAYING] || 0) > EGG_LAYING_THRESHOLD;

            organism.dwellingGeneValue = g[GENE_DWELLING] || 0;
            organism.canDwelling = organism.dwellingGeneValue > DWELLING_GENE_THRESHOLD;

            // NEW GENE INTERPRETATION
            organism.isMyceliumActive = (g[GENE_MYCELIUM] || 0) > MYCELIUM_THRESHOLD;
            // Pathfinding requires sight to be effective
            organism.canPathfind = (g[GENE_PATHFINDING] || 0) > PATHFINDING_THRESHOLD && organism.sightRange > 0;
            // Starvation gene doesn't directly change organism properties here, but influences behavior later.
        }

        function duplicateOrganism(parent, offspringX, offspringY, isInSaltRegion) {
            totalDuplications++;
            const newGenes = [...parent.genes];
            let currentEvolutionChance = EVOLUTION_CHANCE_ON_DUPLICATION;
            if (isInSaltRegion) {
                currentEvolutionChance += SALT_REGION_MUTATION_BOOST * (1 - (parent.saltToleranceFactor || 0));
            }

            let primaryMutationOccurred = false; // Flag to track if a primary mutation happened
            let mutatedNonHueGene = false;

            // Primary mutation attempt
            if (Math.random() < currentEvolutionChance) {
                totalEvolutions++;
                primaryMutationOccurred = true;
                let geneIndexToMutate;
                if (MAX_GENES > 1) {
                    do { geneIndexToMutate = Math.floor(Math.random() * MAX_GENES); } while (geneIndexToMutate === GENE_HUE);
                } else {
                    geneIndexToMutate = 0;
                }

                const oldValue = newGenes[geneIndexToMutate];
                newGenes[geneIndexToMutate] += (Math.random() - 0.5) * GENE_MUTATION_STRENGTH;
                if (geneIndexToMutate === GENE_COMPLEXITY) { newGenes[geneIndexToMutate] = Math.max(0, newGenes[geneIndexToMutate]); }
                else { newGenes[geneIndexToMutate] = Math.max(0, Math.min(1, newGenes[geneIndexToMutate])); }

                if (newGenes[geneIndexToMutate] !== oldValue) {
                    mutatedNonHueGene = true;
                }
            }

            // Secondary mutation attempt (1/2 chance if primary mutation occurred)
            if (primaryMutationOccurred && Math.random() < (1/2)) {
                totalEvolutions++; // Count as another evolution
                let geneIndexToMutate;
                // Ensure the secondary mutation isn't the same gene as the primary, unless only one gene exists
                if (MAX_GENES > 1) {
                    // This loop ensures a different gene is mutated for the secondary mutation,
                    // or if only two genes, it could be the hue gene if the first wasn't
                    let initialGeneToAvoid = geneIndexToMutate; // The gene mutated in the primary mutation
                    do {
                        geneIndexToMutate = Math.floor(Math.random() * MAX_GENES);
                    } while (MAX_GENES > 1 && geneIndexToMutate === initialGeneToAvoid); // Avoid mutating the same gene again if multiple genes exist
                } else {
                    geneIndexToMutate = 0; // Only one gene, so mutate it again
                }


                const oldValue = newGenes[geneIndexToMutate];
                newGenes[geneIndexToMutate] += (Math.random() - 0.5) * GENE_MUTATION_STRENGTH;
                if (geneIndexToMutate === GENE_COMPLEXITY) { newGenes[geneIndexToMutate] = Math.max(0, newGenes[geneIndexToMutate]); }
                else { newGenes[geneIndexToMutate] = Math.max(0, Math.min(1, newGenes[geneIndexToMutate])); }

                if (newGenes[geneIndexToMutate] !== oldValue) {
                    mutatedNonHueGene = true; // Even if it's a hue mutation, this flags that *some* non-hue mutation occurred previously, which might be less relevant for the secondary mutation, but good to keep consistent.
                }
            }

            if (mutatedNonHueGene || (Math.random() < currentEvolutionChance && MAX_GENES > 0 && newGenes[GENE_HUE] !== undefined) ) {
                newGenes[GENE_HUE] = (newGenes[GENE_HUE] || 0) + (Math.random() - 0.5) * MINOR_HUE_SHIFT_STRENGTH;
                newGenes[GENE_HUE] = (newGenes[GENE_HUE] + 1) % 1;
            }

            const offspring = createOrganism(offspringX, offspringY, newGenes, parent.birthX, parent.birthY);

            if (parent.isEggLayer) {
                offspring.isEgg = true;
                offspring.eggTimer = EGG_DURATION_SECONDS;
                offspring.strength = EGG_STRENGTH;
                offspring.birthX = offspringX;
                offspring.birthY = offspringY;
            }
            interpretGenes(offspring);
            return offspring;
        }

        function onSegment(px, py, qx, qy, rx, ry) { return (qx <= Math.max(px, rx) && qx >= Math.min(px, rx) && qy <= Math.max(py, ry) && qy >= Math.min(py, ry)); }
        function orientation(px, py, qx, qy, rx, ry) { const val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy); if (val === 0) return 0; return (val > 0) ? 1 : 2; }
        function segmentsIntersect(p1x, p1y, q1x, q1y, p2x, p2y, q2x, q2y) { const o1 = orientation(p1x, p1y, q1x, q1y, p2x, p2y); const o2 = orientation(p1x, p1y, q1x, q1y, q2x, q2y); const o3 = orientation(p2x, p2y, q2x, q2y, p1x, p1y); const o4 = orientation(p2x, p2y, q2x, q2y, q1x, q1y); if (o1 !== 0 && o2 !== 0 && o3 !== 0 && o4 !== 0) { if (o1 !== o2 && o3 !== o4) return true; } if (o1 === 0 && onSegment(p1x, p1y, p2x, p2y, q1x, q1y)) return true; if (o2 === 0 && onSegment(p1x, p1y, q2x, q2y, q1x, q1y)) return true; if (o3 === 0 && onSegment(p2x, p2y, p1x, p1y, q2x, q2y)) return true; if (o4 === 0 && onSegment(p2x, p2y, q1x, q1y, q2x, q2y)) return true; return false;  }
        function getClosestPointOnLineSegment(pX,pY,l1X,l1Y,l2X,l2Y){ const l2_sq=(l1X-l2X)**2+(l1Y-l2Y)**2; if(l2_sq===0)return {x:l1X,y:l1Y, distSq: (pX-l1X)**2 + (pY-l1Y)**2}; let t=((pX-l1X)*(l2X-l1X)+(pY-l1Y)*(l2Y-l1Y))/l2_sq; t=Math.max(0,Math.min(1,t)); const closestX = l1X+t*(l2X-l1X); const closestY = l1Y+t*(l2Y-l1Y); return {x:closestX, y:closestY, distSq: (pX-closestX)**2 + (pY-closestY)**2 }; }

        function generateEnvironment() { walls = []; foodDispensers = []; saltRegions = []; let attempts = 0; const maxAttemptsPerWall = 20; for (let i = 0; i < NUM_CAVE_WALLS && attempts < NUM_CAVE_WALLS * maxAttemptsPerWall; ) { let x1_cand, y1_cand, x2_cand, y2_cand; let length = MIN_WALL_LENGTH + Math.random() * (MAX_WALL_LENGTH - MIN_WALL_LENGTH); let connectedToThisWall = null; let newWallIsValid = true; if (walls.length > 0 && Math.random() < WALL_CONNECTION_PROBABILITY) { const parentWall = walls[Math.floor(Math.random() * walls.length)]; connectedToThisWall = parentWall; let connectionPointX, connectionPointY, parentOtherEndX, parentOtherEndY; if (Math.random() < 0.5) { connectionPointX = parentWall.x1; connectionPointY = parentWall.y1; parentOtherEndX = parentWall.x2; parentOtherEndY = parentWall.y2; } else { connectionPointX = parentWall.x2; connectionPointY = parentWall.y2; parentOtherEndX = parentWall.x1; parentOtherEndY = parentWall.y1; } x1_cand = connectionPointX; y1_cand = connectionPointY; const parentDirectionX = connectionPointX - parentOtherEndX; const parentDirectionY = connectionPointY - parentOtherEndY; const parentSegmentAngle = Math.atan2(parentDirectionY, parentDirectionX); const minVertexAngleRad = MIN_VERTEX_ANGLE_DEG * Math.PI / 180; const maxVertexAngleRad = (180 - MIN_DEFLECTION_FROM_STRAIGHT_DEG) * Math.PI / 180; const minDeflectionRad = Math.PI - maxVertexAngleRad; const maxDeflectionRad = Math.PI - minVertexAngleRad; if (minDeflectionRad >= maxDeflectionRad) { newWallIsValid = false; } else { let deflection = minDeflectionRad + Math.random() * (maxDeflectionRad - minDeflectionRad); const signedDeflection = (Math.random() < 0.5 ? 1 : -1) * deflection; const newWallAngle = parentSegmentAngle + signedDeflection; x2_cand = x1_cand + Math.cos(newWallAngle) * length; y2_cand = y1_cand + Math.sin(newWallAngle) * length; } } else { x1_cand = Math.random() * worldWidth; y1_cand = Math.random() * worldHeight; const angle = Math.random() * Math.PI * 2; x2_cand = x1_cand + Math.cos(angle) * length; y2_cand = y1_cand + Math.sin(angle) * length; } if (!newWallIsValid) { attempts++; continue; } x1_cand = Math.max(WALL_THICKNESS/2, Math.min(worldWidth - WALL_THICKNESS/2, x1_cand)); y1_cand = Math.max(WALL_THICKNESS/2, Math.min(worldHeight - WALL_THICKNESS/2, y1_cand)); x2_cand = Math.max(WALL_THICKNESS/2, Math.min(worldWidth - WALL_THICKNESS/2, x2_cand)); y2_cand = Math.max(WALL_THICKNESS/2, Math.min(worldHeight - WALL_THICKNESS/2, y2_cand)); if (Math.sqrt((x2_cand - x1_cand)**2 + (y2_cand - y1_cand)**2) < MIN_WALL_LENGTH * 0.5) { newWallIsValid = false; } if (newWallIsValid) { for (const existingWall of walls) { if (existingWall === connectedToThisWall) continue; if (segmentsIntersect(x1_cand, y1_cand, x2_cand, y2_cand, existingWall.x1, existingWall.y1, existingWall.x2, existingWall.y2)) { newWallIsValid = false; break; } } } if (newWallIsValid) { walls.push({ x1: x1_cand, y1: y1_cand, x2: x2_cand, y2: y2_cand, thickness: WALL_THICKNESS }); i++; } attempts++; } for (let i = 0; i < NUM_FOOD_DISPENSERS; i++) { foodDispensers.push({ x: Math.random()*worldWidth, y: Math.random()*worldHeight, radius:10, nextDispenseTime: simulationTime + Math.random()*FOOD_DISPENSER_RATE_SECONDS*2 }); } for (let i = 0; i < NUM_SALT_REGIONS; i++) { const regionWidth = worldWidth*(0.1+Math.random()*0.4); const regionHeight = worldHeight*(0.1+Math.random()*0.4); saltRegions.push({ x:Math.random()*(worldWidth-regionWidth), y:Math.random()*(worldHeight-regionHeight), width:regionWidth, height:regionHeight }); } }
        
        function initSimulation() {
            organisms = []; husks = []; simulationTime = 0; lastTickTime = performance.now();
            totalDuplications = 0; totalEvolutions = 0; isPaused = false;
            pauseButton.textContent = "Pause"; viewScale = 1.0; viewOffsetX = 0; viewOffsetY = 0; 
            
            gameSpeedMultiplier = parseFloat(speedSlider.value); // Ensure speed slider reflects initial value
            speedValueEl.textContent = `${gameSpeedMultiplier.toFixed(1)}x`;
            
            maxOrganismsLimit = parseInt(maxOrganismsSlider.value); // Ensure max orgs slider reflects initial value
            maxOrganismsValueEl.textContent = maxOrganismsLimit;

            showScavengerHeatmap = true; // Default ON
            showPreyHeatmap = true;     // Default ON
            showPredatorHeatmap = true;  // Default ON
            updateHeatmapButtonStates(); // Update buttons to reflect initial state

            if (!worldWidth) { // Initialize world size if not already set
                worldWidth = canvas.width * 1.5; 
                worldHeight = canvas.height * 1.5; 
            }
            
            generateEnvironment();
            
            const initialGenes = Array(MAX_GENES).fill(0); // Initialize with MAX_GENES length
            initialGenes[GENE_HUE]=Math.random(); initialGenes[GENE_BASE_SIZE]=0.1; initialGenes[GENE_DUP_RATE]=0.1; initialGenes[GENE_FLAGELLA]=0;
            initialGenes[GENE_HOSTILITY]=0.3; initialGenes[GENE_SIGHT_RANGE]=0; initialGenes[GENE_FEAR_FACTOR]=0.2; initialGenes[GENE_PREDATOR_DRIVE]=0.2;
            initialGenes[GENE_COMPLEXITY]=0; initialGenes[GENE_SCAVENGER]=0.2; 
            initialGenes[GENE_SALT_TOLERANCE]=0.1; initialGenes[GENE_SALT_AVOIDANCE]=0.4; initialGenes[GENE_PLASMODIUM] = 0.4;
            initialGenes[GENE_WALL_ATTRACTION] = 0.1; 
            initialGenes[GENE_HERD_MENTALITY] = 0.3;
            initialGenes[GENE_EGG_LAYING] = 0.4;
            initialGenes[GENE_DWELLING] = 0.2;
            // Initialize new genes
            initialGenes[GENE_MYCELIUM] = 0.5;
            initialGenes[GENE_PATHFINDING] = 0.2;
            initialGenes[GENE_STARVATION] = 0.2; // Initialize starvation gene

            const initialOrganism = createOrganism(worldWidth/2, worldHeight/2, initialGenes);
            interpretGenes(initialOrganism); organisms.push(initialOrganism);
            if (animationFrameId) cancelAnimationFrame(animationFrameId); gameLoop();
        }

        function updateStats() { organismCountEl.textContent=organisms.length; elapsedTimeEl.textContent=Math.floor(simulationTime); duplicationCountEl.textContent=totalDuplications; evolutionCountEl.textContent=totalEvolutions; }
        function screenToWorld(screenX, screenY) { const rect=canvas.getBoundingClientRect(); const canvasX=screenX-rect.left; const canvasY=screenY-rect.top; return {x:(canvasX/viewScale)+viewOffsetX, y:(canvasY/viewScale)+viewOffsetY}; }
        function worldToScreen(worldX, worldY) { return {x:(worldX-viewOffsetX)*viewScale, y:(worldY-viewOffsetY)*viewScale}; }
        function clampViewOffset() { const minScaleX=canvas.width/worldWidth; const minScaleY=canvas.height/worldHeight; const minScale=Math.max(minScaleX,minScaleY); viewScale=Math.max(minScale,viewScale); viewScale=Math.min(5,viewScale); const scaledCanvasWidth=canvas.width/viewScale; const scaledCanvasHeight=canvas.height/viewScale; let minViewOffsetX=0; let maxViewOffsetX=worldWidth-scaledCanvasWidth; let minViewOffsetY=0; let maxViewOffsetY=worldHeight-scaledCanvasHeight; if(scaledCanvasWidth>=worldWidth){viewOffsetX=(worldWidth-scaledCanvasWidth)/2;}else{viewOffsetX=Math.max(minViewOffsetX,Math.min(viewOffsetX,maxViewOffsetX));} if(scaledCanvasHeight>=worldHeight){viewOffsetY=(worldHeight-scaledCanvasHeight)/2;}else{viewOffsetY=Math.max(minViewOffsetY,Math.min(viewOffsetY,maxViewOffsetY));}}
        function isPointInSaltRegion(x,y){ for(const region of saltRegions){if(x>=region.x && x<=region.x+region.width && y>=region.y && y<=region.y+region.height){return region;}} return null;}
        function findClosestWallPoint(organism) { let closestWall = null; let closestPoint = null; let minDistanceSq = Infinity; for (const wall of walls) { const pointInfo = getClosestPointOnLineSegment(organism.x, organism.y, wall.x1, wall.y1, wall.x2, wall.y2); if (pointInfo.distSq < minDistanceSq) { minDistanceSq = pointInfo.distSq; closestPoint = { x: pointInfo.x, y: pointInfo.y }; closestWall = wall; } } return closestPoint; }


        function update(currentTime) {
            if (isPaused) return;
            let rawDeltaTime = (currentTime - lastTickTime) / 1000;
            if (rawDeltaTime <= 0) { lastTickTime = currentTime; return; } // Avoid issues with timestamp irregularities
            const deltaTime = rawDeltaTime * gameSpeedMultiplier;
            simulationTime += deltaTime;
            const newOrganisms = []; const deadOrConsumedOrganismIds = new Set(); const consumedHuskIds = new Set();

            // Clear mycelium connections for this frame
            myceliumConnections.clear();

            // Mycelium network processing - START
            const visitedMyceliumOrgs = new Set();
            organisms.forEach(org => {
                if (org.isEgg || org.genes[GENE_MYCELIUM] < MYCELIUM_THRESHOLD || visitedMyceliumOrgs.has(org.id) || org.genes[GENE_FLAGELLA] >= 0.05) {
                    return;
                }

                const network = [];
                const queue = [org];
                visitedMyceliumOrgs.add(org.id);

                let head = 0;
                while (head < queue.length) {
                    const currentOrg = queue[head++];
                    network.push(currentOrg);

                    organisms.forEach(otherOrg => {
                        // Check if the other organism is valid for network, not visited, and has mycelium gene
                        if (otherOrg.isEgg || otherOrg.id === currentOrg.id || visitedMyceliumOrgs.has(otherOrg.id) || otherOrg.genes[GENE_MYCELIUM] < MYCELIUM_THRESHOLD || otherOrg.genes[GENE_FLAGELLA] >= 0.05) {
                            return;
                        }
                        const dx = otherOrg.x - currentOrg.x;
                        const dy = otherOrg.y - currentOrg.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        // Check if touching (or very close)
                        if (distance < currentOrg.radius + otherOrg.radius + 12) { // Add a small buffer for "touching"
                            queue.push(otherOrg);
                            visitedMyceliumOrgs.add(otherOrg.id);
                            // Add connection for drawing
                            const connectionKey = [currentOrg.id, otherOrg.id].sort().join('-');
                            myceliumConnections.add(connectionKey);
                        }
                    });
                }

                if (network.length > 1) { // Only process if it's a true network with more than one organism
                    let totalLifespan = 0;
                    network.forEach(nOrg => {
                        totalLifespan += nOrg.timeToLive;
                    });
                    const averageLifespan = totalLifespan / network.length;

                    network.forEach(nOrg => {
                        if (nOrg.timeToLive < averageLifespan) {
                            nOrg.timeToLive += deltaTime * 3;
                        } else if (nOrg.timeToLive > averageLifespan) {
                            nOrg.timeToLive -= deltaTime * 2;
                        }
                        // Ensure lifespan doesn't go below zero and doesn't exceed a reasonable cap (e.g., 3x initial TTL)
                        nOrg.timeToLive = Math.max(0, Math.min(nOrg.timeToLive, nOrg.initialTimeToLive * 3));
                    });
                }
            });
            // Mycelium network processing - END


            foodDispensers.forEach(dispenser => { if (simulationTime >= dispenser.nextDispenseTime) { const angle = Math.random()*Math.PI*2; const husk={id:'husk_dispensed_'+Date.now()+'_'+Math.random(),x:dispenser.x,y:dispenser.y,radius:HUSK_DEFAULT_RADIUS,vx:Math.cos(angle)*FOOD_DISPENSER_HUSK_SPEED,vy:Math.sin(angle)*FOOD_DISPENSER_HUSK_SPEED,isDispensed:true,timeToLiveDispensed:60, cellCount:1}; husks.push(husk); dispenser.nextDispenseTime = simulationTime + (Math.random()*0.5+0.75)*FOOD_DISPENSER_RATE_SECONDS;}});
            husks.forEach(husk => { if (husk.isDispensed) { husk.x+=husk.vx*deltaTime; husk.y+=husk.vy*deltaTime; husk.vx*=0.98; husk.vy*=0.98; husk.timeToLiveDispensed-=deltaTime; if(husk.timeToLiveDispensed<=0){consumedHuskIds.add(husk.id);} if(husk.x-husk.radius<0||husk.x+husk.radius>worldWidth||husk.y-husk.radius<0||husk.y+husk.radius>worldHeight){consumedHuskIds.add(husk.id);} walls.forEach(wall=>{const closestPoint=getClosestPointOnLineSegment(husk.x,husk.y,wall.x1,wall.y1,wall.x2,wall.y2); const dx=husk.x-closestPoint.x; const dy=husk.y-closestPoint.y; const distSq=dx*dx+dy*dy; const totalRadiusSq=(husk.radius+wall.thickness/2)**2; if(distSq<totalRadiusSq){consumedHuskIds.add(husk.id);}});}});

            organisms.forEach(org => {
                if(deadOrConsumedOrganismIds.has(org.id))return; 
                org.age+=deltaTime; 
                if(org.eatCooldown>0)org.eatCooldown-=deltaTime; 
                const currentSaltRegion=isPointInSaltRegion(org.x,org.y);
                
                if (org.isEgg) {
                    org.eggTimer -= deltaTime;
                    if (org.eggTimer <= 0) {
                        org.isEgg = false;
                        org.birthX = org.x; 
                        org.birthY = org.y;
                        org.initialTimeToLive = LIFESPAN_PER_CELLCOUNT_SECONDS * org.cellCount;
                        org.timeToLive = org.initialTimeToLive; 
                        interpretGenes(org); 
                    } else {
                        org.vx = 0; org.vy = 0;
                        org.x=Math.max(org.radius,Math.min(worldWidth-org.radius,org.x));
                        org.y=Math.max(org.radius,Math.min(worldHeight-org.radius,org.y));
                        return; 
                    }
                }
                
                if(org.age>=org.timeToLive){deadOrConsumedOrganismIds.add(org.id); husks.push({id:'husk_'+org.id+'_'+Date.now(),x:org.x,y:org.y,radius:org.radius*0.5,cellCount:org.cellCount}); return;}

                org.plasmodiumTargetHusk = null; 
                if (org.isPlasmodiumActive && org.plasmodiumEffectRadius > 0) {
                    let closestHuskInPlasma = null; let minDistSqToHuskInPlasma = Infinity;
                    husks.forEach(husk => {
                        if (consumedHuskIds.has(husk.id)) return;
                        const dx = husk.x - org.x; const dy = husk.y - org.y; const distSq = dx*dx + dy*dy;
                        if (distSq < (org.plasmodiumEffectRadius)**2 ) { 
                            if (distSq < minDistSqToHuskInPlasma) { minDistSqToHuskInPlasma = distSq; closestHuskInPlasma = husk; }
                        }
                    });
                    if (closestHuskInPlasma) { org.plasmodiumTargetHusk = { x: closestHuskInPlasma.x, y: closestHuskInPlasma.y, id: closestHuskInPlasma.id }; }
                }

                if(Math.random()<org.actualDuplicationChance*deltaTime){
                    const angle=Math.random()*Math.PI*2; const offset=org.radius*2.5;
                    let offspringX = org.x + Math.cos(angle)*offset; let offspringY = org.y + Math.sin(angle)*offset;
                    if (org.isPlasmodiumActive && org.plasmodiumTargetHusk) {
                        const targetHuskStillExists = husks.find(h => h.id === org.plasmodiumTargetHusk.id && !consumedHuskIds.has(h.id));
                        if (targetHuskStillExists) { offspringX = org.plasmodiumTargetHusk.x; offspringY = org.plasmodiumTargetHusk.y; }
                    }
                    let potentialNewX = offspringX; let potentialNewY = offspringY;
                    potentialNewX=Math.max(org.radius,Math.min(worldWidth-org.radius,potentialNewX));
                    potentialNewY=Math.max(org.radius,Math.min(worldHeight-org.radius,potentialNewY));
                    let nearbyCellCount=0; const crowdingCheckRadiusSq=CROWDING_CHECK_RADIUS*CROWDING_CHECK_RADIUS;
                    for(const other of organisms){if(org.id===other.id)continue;const dx=other.x-potentialNewX;const dy=other.y-potentialNewY;if((dx*dx+dy*dy)<crowdingCheckRadiusSq)nearbyCellCount+=other.cellCount;}
                    for(const newOrgCand of newOrganisms){const dx=newOrgCand.x-potentialNewX;const dy=newOrgCand.y-potentialNewY;if((dx*dx+dy*dy)<crowdingCheckRadiusSq)nearbyCellCount+=newOrgCand.cellCount;}
                    
                    // Use maxOrganismsLimit here
                    if(nearbyCellCount<=MAX_NEARBY_CELLS_FOR_DUPLICATION && (organisms.length + newOrganisms.length) < maxOrganismsLimit){
                        newOrganisms.push(duplicateOrganism(org,potentialNewX,potentialNewY,!!currentSaltRegion));
                    }
                }
                
                // Determine if organism is starving
                const isStarving = org.timeToLive < STARVATION_THRESHOLD_LIFESPAN && (org.genes[GENE_STARVATION] || 0) > STARVATION_GENE_ACTIVATION_THRESHOLD;

                // Determine if organism wants to leave salt (this will influence targetVx/Vy directly)
                let wantsToLeaveSalt = false;
                let saltAvoidanceForceX = 0;
                let saltAvoidanceForceY = 0;
                // Starvation overrides salt avoidance
                if (!isStarving && org.avoidsSalt && currentSaltRegion && (org.saltToleranceFactor < 0.8)) {
                    wantsToLeaveSalt = true;
                    const saltCenterX = currentSaltRegion.x + currentSaltRegion.width / 2;
                    const saltCenterY = currentSaltRegion.y + currentSaltRegion.height / 2;
                    // Apply force to move away from salt center
                    saltAvoidanceForceX = (org.x - saltCenterX) * 0.1;
                    saltAvoidanceForceY = (org.y - saltCenterY) * 0.1;
                }

                // Reset targets and behaviors for this frame
                org.flees = false;
                org.hunts = false;
                org.isScavenging = false;
                org.isDwelling = false;
                org.targetOrganism = null;
                org.targetHusk = null;
                org.targetWallPoint = null;
                org.targetHerdCenter = null;
                org.targetDwellingPoint = null;
                org.targetPoint = null; // NEW: Reset target point for movement calculation

                // Re-interpret genes (important for any gene value changes, though unlikely for this frame)
                interpretGenes(org);

                // Find potential targets if organism has sight and is not on eating cooldown
                let bestPrey = null;
                let strongestThreat = null;
                let potentialScavengerThreat = null;
                let bestHuskTarget = null;
                let herdMembers = [];

                if (org.sightRange > 0 && org.eatCooldown <= 0) {
                    organisms.forEach(other => {
                        if (org === other || deadOrConsumedOrganismIds.has(other.id) || other.isEgg) return;
                        const dx = other.x - org.x;
                        const dy = other.y - org.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) - other.radius - org.radius;

                        if (distance < org.sightRange) {
                            const canWinEngagement = (org.strength > other.strength) || (org.strength === other.strength && org.radius > other.radius);
                            const isEdibleByMulticell = !(org.cellCount > 1 && other.cellCount === 1 && other.radius < MIN_RADIUS_TO_EAT_BY_MULTICELLULAR);

                            if ((org.genes[GENE_PREDATOR_DRIVE] || 0) > PREDATOR_DRIVE_THRESHOLD && org.isHostile && canWinEngagement && isEdibleByMulticell && JSON.stringify(org.genes) !== JSON.stringify(other.genes)) {
                                if (bestPrey === null || distance < (Math.sqrt((bestPrey.x - org.x)**2 + (bestPrey.y - org.y)**2) - bestPrey.radius - org.radius)) {
                                    bestPrey = other;
                                }
                            }

                            const isThreat = other.isHostile && (other.strength > org.strength * 1.5 || (org.isHostile && other.strength > org.strength && !canWinEngagement));
                            if (((org.genes[GENE_FEAR_FACTOR] || 0) > FEAR_FACTOR_THRESHOLD || (org.isHostile && isThreat)) && isThreat) {
                                if (strongestThreat === null || distance < (Math.sqrt((strongestThreat.x - org.x)**2 + (strongestThreat.y - org.y)**2) - strongestThreat.radius - org.radius)) {
                                    strongestThreat = other;
                                }
                            }

                            // Check for potential scavenger threat (hostile organism that could threaten a scavenger)
                            if (org.isScavenger && (org.genes[GENE_FEAR_FACTOR] || 0) > (org.genes[GENE_SCAVENGER] || 0) * 0.5 && other.isHostile) {
                                if (potentialScavengerThreat === null || distance < (Math.sqrt((potentialScavengerThreat.x - org.x)**2 + (potentialScavengerThreat.y - org.y)**2) - potentialScavengerThreat.radius - org.radius)) {
                                    potentialScavengerThreat = other;
                                }
                            }

                            // Herd mentality: only stick with other herd mentality organisms
                            if (org.seeksHerd && other.seeksHerd && distance < org.sightRange * HERD_DETECTION_RADIUS_MULTIPLIER) {
                                const isDirectThreatOrPrey = (strongestThreat && strongestThreat.id === other.id) || (bestPrey && bestPrey.id === other.id);
                                if (!isDirectThreatOrPrey) {
                                    herdMembers.push(other);
                                }
                            }
                        }
                    });

                    if (org.isScavenger) {
                        husks.forEach(husk => {
                            if (consumedHuskIds.has(husk.id)) return;
                            const dx = husk.x - org.x;
                            const dy = husk.y - org.y;
                            const distance = Math.sqrt(dx * dx + dy * dy) - husk.radius - org.radius;
                            if (distance < org.sightRange) {
                                if (bestHuskTarget === null || (distance < (Math.sqrt((bestHuskTarget.x - org.x)**2 + (bestHuskTarget.y - org.y)**2) - bestHuskTarget.radius - org.radius) && husk.radius <= org.radius)) {
                                    bestHuskTarget = husk;
                                }
                            }
                        });
                    }
                }

                // Primary behavior determination based on priorities
                if (isStarving && (bestHuskTarget || (bestPrey && org.isHostile))) {
                    // Starvation overrides fear
                    if (bestHuskTarget) {
                        org.isScavenging = true;
                        org.targetHusk = bestHuskTarget;
                        org.targetPoint = { x: bestHuskTarget.x, y: bestHuskTarget.y }; // Set target point
                    } else if (bestPrey && org.isHostile) {
                        org.hunts = true;
                        org.targetOrganism = bestPrey;
                        org.targetPoint = { x: bestPrey.x, y: bestPrey.y }; // Set target point
                    }
                } else if (strongestThreat) {
                    org.flees = true;
                    org.targetOrganism = strongestThreat;
                    org.targetPoint = { x: org.x + (org.x - strongestThreat.x), y: org.y + (org.y - strongestThreat.y) }; // Set target point (move away)
                } else if (org.isScavenger && potentialScavengerThreat && bestHuskTarget) {
                    // Scavenger/Fear conflict resolution: compare fear vs scavenger gene
                    if ((org.genes[GENE_FEAR_FACTOR] || 0) > (org.genes[GENE_SCAVENGER] || 0)) {
                        org.flees = true;
                        org.targetOrganism = potentialScavengerThreat;
                        org.targetPoint = { x: org.x + (org.x - potentialScavengerThreat.x), y: org.y + (org.y - potentialScavengerThreat.y) }; // Set target point (move away)
                    } else {
                        org.isScavenging = true;
                        org.targetHusk = bestHuskTarget;
                        org.targetPoint = { x: bestHuskTarget.x, y: bestHuskTarget.y }; // Set target point
                    }
                } else if (bestPrey && org.isHostile) {
                    org.hunts = true;
                    org.targetOrganism = bestPrey;
                    org.targetPoint = { x: bestPrey.x, y: bestPrey.y }; // Set target point
                } else if (bestHuskTarget && org.isScavenger) {
                    org.isScavenging = true;
                    org.targetHusk = bestHuskTarget;
                    org.targetPoint = { x: bestHuskTarget.x, y: bestHuskTarget.y }; // Set target point
                } else if (org.canDwelling && org.timeToLive > org.initialTimeToLive * DWELLING_LIFESPAN_SATISFACTION_RATIO) {
                    const distToBirthSq = (org.x - org.birthX)**2 + (org.y - org.birthY)**2;
                    if (distToBirthSq > (DWELLING_REACH_THRESHOLD * 2)**2) {
                         org.isDwelling = true;
                         org.targetDwellingPoint = { x: org.birthX, y: org.birthY };
                         org.targetPoint = { x: org.birthX, y: org.birthY }; // Set target point
                    }
                } else if (org.isAttractedToWalls && walls.length > 0) {
                    org.targetWallPoint = findClosestWallPoint(org);
                    if (org.targetWallPoint) { // Ensure targetWallPoint is found before setting targetPoint
                        org.targetPoint = org.targetWallPoint; // Set target point
                    }
                } else if (org.seeksHerd && herdMembers.length > 0) {
                    let herdCenterX = 0;
                    let herdCenterY = 0;
                    herdMembers.forEach(member => {
                        herdCenterX += member.x;
                        herdCenterY += member.y;
                    });
                    herdCenterX /= herdMembers.length;
                    herdCenterY /= herdMembers.length;
                    org.targetHerdCenter = { x: herdCenterX, y: herdCenterY };
                    org.targetPoint = { x: herdCenterX, y: herdCenterY }; // Set target point
                }
                
                // Calculate target velocity based on selected behavior and additional forces
                let targetVx = 0; // Initialize to 0
                let targetVy = 0;

                if (org.targetPoint) {
                    const dx = org.targetPoint.x - org.x;
                    const dy = org.targetPoint.y - org.y;
                    const distToTarget = Math.sqrt(dx * dx + dy * dy);
                    if (distToTarget > 0) {
                        targetVx = (dx / distToTarget) * org.speed;
                        targetVy = (dy / distToTarget) * org.speed;
                    }
                } else if (!wantsToLeaveSalt && org.speed > 0) {
                    // Random movement fallback if no specific target
                    if (Math.random() < 0.05) {
                        const angle = Math.random() * Math.PI * 2;
                        targetVx = Math.cos(angle) * org.speed * 0.3;
                        targetVy = Math.sin(angle) * org.speed * 0.3;
                    }
                }

                // Apply salt avoidance force
                targetVx += saltAvoidanceForceX;
                targetVy += saltAvoidanceForceY;

                // Pathfinding logic - START
                if (org.canPathfind) {
                    const wallDetectionRadius = org.radius * WALL_DETECTION_RANGE_MULTIPLIER;
                    let wallInfluenceX = 0;
                    let wallInfluenceY = 0;

                    walls.forEach(wall => {
                        const closestPoint = getClosestPointOnLineSegment(org.x, org.y, wall.x1, wall.y1, wall.x2, wall.y2);
                        const dx = org.x - closestPoint.x;
                        const dy = org.y - closestPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < wallDetectionRadius + wall.thickness / 2) {
                            const normX = dx / distance;
                            const normY = dy / distance;

                            // Apply wall avoidance force if fleeing OR trying to leave salt
                            if (org.flees || wantsToLeaveSalt) { // MODIFIED: Pathfinding for salt avoidance
                                wallInfluenceX += normX * WALL_AVOIDANCE_FORCE;
                                wallInfluenceY += normY * WALL_AVOIDANCE_FORCE;
                            } else if (org.hunts || org.isScavenging) {
                                // Hunting/Scavenging: steer around the wall if it's between the organism and target
                                let targetX, targetY;
                                if (org.targetOrganism) {
                                    const target = organisms.find(o => o.id === org.targetOrganism.id && !deadOrConsumedOrganismIds.has(o.id));
                                    if (target) { targetX = target.x; targetY = target.y; }
                                } else if (org.targetHusk) {
                                    const target = husks.find(h => h.id === org.targetHusk.id && !consumedHuskIds.has(h.id));
                                    if (target) { targetX = target.x; targetY = target.y; }
                                }

                                if (targetX !== undefined && targetY !== undefined) {
                                    const orgToTargetX = targetX - org.x;
                                    const orgToTargetY = targetY - org.y;
                                    const orgToWallX = closestPoint.x - org.x;
                                    const orgToWallY = closestPoint.y - org.y;

                                    // Check if the wall is generally in the direction of the target
                                    const dotProduct = orgToTargetX * orgToWallX + orgToTargetY * orgToWallY;
                                    if (dotProduct > 0) { 
                                        // Calculate perpendicular vector to the wall segment
                                        const wallDirX = wall.x2 - wall.x1;
                                        const wallDirY = wall.y2 - wall.y1;
                                        const wallLength = Math.sqrt(wallDirX * wallDirX + wallDirY * wallDirY);
                                        if (wallLength > 0) {
                                            const perpX = -wallDirY / wallLength; // Perpendicular vector (one direction)
                                            const perpY = wallDirX / wallLength;

                                            // Apply force to steer away from the wall, towards the side where the target is
                                            // This cross product determines which side of the wall the target is on
                                            const crossProduct = (targetX - closestPoint.x) * wallDirY - (targetY - closestPoint.y) * wallDirX;

                                            if (crossProduct > 0) { 
                                                wallInfluenceX += perpX * WALL_STEERING_FORCE;
                                                wallInfluenceY += perpY * WALL_STEERING_FORCE;
                                            } else { 
                                                wallInfluenceX -= perpX * WALL_STEERING_FORCE;
                                                wallInfluenceY -= perpY * WALL_STEERING_FORCE;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                    targetVx += wallInfluenceX;
                    targetVy += wallInfluenceY;
                }
                // Pathfinding logic - END
                
                const inertiaFactor=org.speed>0?0.05:1;org.vx+=(targetVx-org.vx)*inertiaFactor;org.vy+=(targetVy-org.vy)*inertiaFactor;
                
                // Apply global drag
                org.vx *= DRAG_FACTOR; 
                org.vy *= DRAG_FACTOR; 

                if(org.speed===0&&!wantsToLeaveSalt){org.vx*=0.9;org.vy*=0.9;}
                else{const currentSpeedVal=Math.sqrt(org.vx**2+org.vy**2);if(currentSpeedVal>org.speed*1.5&&org.speed>0){org.vx=(org.vx/currentSpeedVal)*org.speed*1.5;org.vy=(org.vy/currentSpeedVal)*org.speed*1.5;}}
                
                org.x+=org.vx*deltaTime;org.y+=org.vy*deltaTime;
                
                walls.forEach(wall=>{const closestPoint=getClosestPointOnLineSegment(org.x,org.y,wall.x1,wall.y1,wall.x2,wall.y2);const dx=org.x-closestPoint.x;const dy=org.y-closestPoint.y;const distSq=dx*dx+dy*dy;const totalRadius=org.radius+wall.thickness/2;if(distSq<totalRadius*totalRadius&&distSq>0){const dist=Math.sqrt(distSq);const overlap=totalRadius-dist;const pushX=(dx/dist)*overlap;const pushY=(dy/dist)*overlap;org.x+=pushX;org.y+=pushY;const dotProduct=org.vx*(closestPoint.x-org.x)+org.vy*(closestPoint.y-org.y);if(dotProduct<0){org.vx*=-0.3;org.vy*=-0.3;}}else if (distSq === 0) { /* If organism is exactly on the wall, nudge it */ org.x+=(Math.random()-0.5)*0.1;org.y+=(Math.random()-0.5)*0.1;}});
                const bounceFactor=-0.5;if(org.x-org.radius<0){org.x=org.radius;org.vx*=bounceFactor;}else if(org.x+org.radius>worldWidth){org.x=worldWidth-org.radius;org.vx*=bounceFactor;} if(org.y-org.radius<0){org.y=org.radius;org.vy*=bounceFactor;}else if(org.y+org.radius>worldHeight){org.y=worldHeight-org.radius;org.vy*=bounceFactor;}
                organisms.forEach(other=>{if(org===other||deadOrConsumedOrganismIds.has(other.id)||other.isEgg)return;const dx=other.x-org.x;const dy=other.y-org.y;const distanceSq=dx*dx+dy*dy;const sumRadii=org.radius+other.radius;if(distanceSq<sumRadii*sumRadii&&distanceSq>0){const isEatingScenario=org.isHostile&&((org.strength>other.strength)||(org.strength===other.strength&&org.radius>other.radius));if(!isEatingScenario){const distance=Math.sqrt(distanceSq);const overlap=sumRadii-distance;const pushX=(dx/distance)*overlap*0.5;const pushY=(dy/distance)*overlap*0.5;org.x-=pushX;org.y-=pushY;other.x+=pushX;other.y+=pushY;const tempVx=org.vx;const tempVy=org.vy;org.vx=other.vx*0.5;org.vy=other.vy*0.5;other.vx=tempVx*0.5;other.vy=tempVy*0.5;}}});
                
                if(org.isHostile&&org.eatCooldown<=0){
                    organisms.forEach(other=>{
                        if(org===other||deadOrConsumedOrganismIds.has(other.id)||deadOrConsumedOrganismIds.has(org.id))return;
                        const dx=other.x-org.x;const dy=other.y-org.y;const distance=Math.sqrt(dx*dx+dy*dy);
                        if(distance<org.radius+other.radius){
                            let orgWins=false;
                            if (other.isEgg) { orgWins = true; } 
                            else { const isEdibleByMulticell=!(org.cellCount>1&&other.cellCount===1&&other.radius<MIN_RADIUS_TO_EAT_BY_MULTICELLULAR); if(JSON.stringify(org.genes)!==JSON.stringify(other.genes)&&isEdibleByMulticell){ if(org.strength>other.strength)orgWins=true; else if(org.strength===other.strength&&org.radius>other.radius)orgWins=true; } }
                            if(orgWins){
                                deadOrConsumedOrganismIds.add(other.id);
                                org.radius=Math.min(MAX_RADIUS_CAP,org.radius+other.radius*CONSUMPTION_SIZE_BOOST);
                                if (!other.isEgg) { org.genes[GENE_BASE_SIZE]=Math.min(1,(org.genes[GENE_BASE_SIZE]||0)+(other.genes[GENE_BASE_SIZE]||0)*CONSUMPTION_SIZE_BOOST*0.1); }
                                let lifespanGain=LIFESPAN_EXTENSION_PER_CONSUMED_CELL_SECONDS*(other.isEgg ? 1 : other.cellCount); 
                                if(currentSaltRegion){lifespanGain*=(1-(SALT_REGION_LIFESPAN_REDUCTION*(1-org.saltToleranceFactor)));} 
                                if (org.isEggLayer) lifespanGain *= EGG_LIFESPAN_FOOD_BONUS; 
                                org.timeToLive+=lifespanGain;
                                org.eatCooldown=EATING_COOLDOWN_SECONDS;
                                interpretGenes(org); 
                            }
                        }
                    });
                }
                else if(org.eatCooldown<=0){ 
                    husks.forEach(husk=>{
                        if(consumedHuskIds.has(husk.id))return;
                        const dx=husk.x-org.x;const dy=husk.y-org.y;const distance=Math.sqrt(dx*dx+dy*dy);
                        const canEatHusk = !org.isScavenger || (org.isScavenger && husk.radius <= org.radius);
                        if(distance<org.radius+husk.radius && canEatHusk){
                            consumedHuskIds.add(husk.id);
                            let lifespanGain=LIFESPAN_EXTENSION_FROM_HUSK*(husk.cellCount||1);
                            if(husk.isDispensed)lifespanGain*=0.5;
                            if(currentSaltRegion){lifespanGain*=(1-(SALT_REGION_LIFESPAN_REDUCTION*(1-org.saltToleranceFactor)));} 
                            if (org.isEggLayer) lifespanGain *= EGG_LIFESPAN_FOOD_BONUS; 
                            org.timeToLive+=lifespanGain;
                            org.eatCooldown=EATING_COOLDOWN_SECONDS;
                        }
                    });
                }
            });
            
            organisms=organisms.filter(org=>!deadOrConsumedOrganismIds.has(org.id));
            husks=husks.filter(husk=>!consumedHuskIds.has(husk.id));
            organisms.push(...newOrganisms);
            lastTickTime=currentTime;
            updateStats();
        }

        function getCellOffsets(numCells, baseOffsetScale, rotation = 0) { const offsets = []; const angleOffset = rotation; if (numCells <= 0) return [{x:0, y:0}]; if (numCells === 1) { offsets.push({ x: 0, y: 0 }); } else if (numCells === 2) { const d = baseOffsetScale * 0.7; offsets.push({ x: -d*Math.cos(angleOffset), y: -d*Math.sin(angleOffset) }); offsets.push({ x: d*Math.cos(angleOffset), y: d*Math.sin(angleOffset) }); } else if (numCells === 3) { const r = baseOffsetScale * 0.9; for (let i=0; i<3; i++) offsets.push({ x: r*Math.cos(i*2*Math.PI/3 + angleOffset), y: r*Math.sin(i*2*Math.PI/3 + angleOffset) }); } else if (numCells === 4) { const d = baseOffsetScale * 1.0; const ba=[Math.PI/4, 3*Math.PI/4, 5*Math.PI/4, 7*Math.PI/4]; for (let i=0; i<4; i++) offsets.push({ x: d*Math.cos(ba[i]+angleOffset), y: d*Math.sin(ba[i]+angleOffset) }); } else { offsets.push({ x: 0, y: 0 }); const noc = numCells - 1; if (noc > 0) { const as = (Math.PI*2)/noc; let rrf=1.5; if (noc>12) rrf=1.8; if (noc>24) rrf=2.2; let rr=baseOffsetScale*rrf; rr=Math.max(rr, (noc*baseOffsetScale*0.35)/Math.PI); for (let i=0; i<noc; i++) offsets.push({x:rr*Math.cos(i*as+angleOffset), y:rr*Math.sin(i*as+angleOffset)});}} return offsets; }
        
        function draw() { 
            ctx.clearRect(0,0,canvas.width,canvas.height); 
            ctx.save(); 
            ctx.scale(viewScale,viewScale); 
            ctx.translate(-viewOffsetX,-viewOffsetY); 
            
            // Draw salt regions
            ctx.fillStyle=SALT_REGION_TINT_COLOR; 
            saltRegions.forEach(region=>{ctx.fillRect(region.x,region.y,region.width,region.height);}); 
            
            // Draw walls
            ctx.strokeStyle='#555e70'; 
            ctx.lineWidth=WALL_THICKNESS; 
            walls.forEach(wall=>{ctx.beginPath();ctx.moveTo(wall.x1,wall.y1);ctx.lineTo(wall.x2,wall.y2);ctx.stroke();}); 
            
            // Draw food dispensers
            ctx.fillStyle='#4a5568'; 
            foodDispensers.forEach(dispenser=>{ctx.beginPath();ctx.arc(dispenser.x,dispenser.y,dispenser.radius,0,Math.PI*2);ctx.fill();}); 
            
            // Draw heatmaps
            if(showScavengerHeatmap){ctx.fillStyle=HEATMAP_SCAVENGER_COLOR;organisms.forEach(org=>{if(org.isScavenger && !org.isEgg){ctx.beginPath();ctx.arc(org.x,org.y,org.radius*HEATMAP_RADIUS_MULTIPLIER,0,Math.PI*2);ctx.fill();}}); } 
            if(showPreyHeatmap){ctx.fillStyle=HEATMAP_PREY_COLOR;organisms.forEach(org=>{if(org.flees && !org.isEgg){ctx.beginPath();ctx.arc(org.x,org.y,org.radius*HEATMAP_RADIUS_MULTIPLIER,0,Math.PI*2);ctx.fill();}}); } 
            if(showPredatorHeatmap){ctx.fillStyle=HEATMAP_PREDATOR_COLOR;organisms.forEach(org=>{if(org.isHostile && !org.isEgg){ctx.beginPath();ctx.arc(org.x,org.y,org.radius*HEATMAP_RADIUS_MULTIPLIER,0,Math.PI*2);ctx.fill();}}); } 
            
            // Draw husks
            husks.forEach(husk=>{ctx.beginPath();ctx.arc(husk.x,husk.y,husk.radius,0,Math.PI*2);ctx.fillStyle=HUSK_COLOR;ctx.fill();}); 
            
            // Draw mycelium connections
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; // Faint white color
            ctx.lineWidth = 0.5;
            myceliumConnections.forEach(key => {
                const [id1, id2] = key.split('-');
                const org1 = organisms.find(o => o.id === id1);
                const org2 = organisms.find(o => o.id === id2);

                if (org1 && org2) {
                    ctx.beginPath();
                    ctx.moveTo(org1.x, org1.y);
                    ctx.lineTo(org2.x, org2.y);
                    ctx.stroke();
                }
            });

            // Draw organisms
            organisms.forEach(org=>{ 
                if (org.isPlasmodiumActive && org.plasmodiumEffectRadius > 0 && !org.isEgg) { 
                    ctx.fillStyle = `hsla(${Math.floor((org.genes[GENE_HUE] || 0) * 360)}, 70%, 60%, ${PLASMODIUM_TINT_ALPHA})`; 
                    ctx.beginPath(); 
                    ctx.arc(org.x, org.y, org.plasmodiumEffectRadius, 0, Math.PI * 2); 
                    ctx.fill(); 
                } 
                let fillStyle = org.color; 
                if (org.isEgg) { 
                    fillStyle = EGG_COLOR; 
                } else if (org.isHostile) { 
                    fillStyle = `hsl(${Math.floor((org.genes[GENE_HUE]||0)*360)}, 90%, 45%)`; 
                } 
                ctx.fillStyle = fillStyle; 
                if(!org.cellCount||org.cellCount<=0||org.isEgg){ 
                    ctx.beginPath();ctx.arc(org.x,org.y,org.radius,0,Math.PI*2);ctx.fill(); 
                } else{ 
                    const numCells=org.cellCount; 
                    const individualCellRadius=Math.max(1.5,org.radius/(Math.sqrt(numCells)*0.8+0.2)); 
                    const cellLayoutScale=individualCellRadius*0.7; 
                    const uniqueAngleOffset=(org.id.charCodeAt(0)%16/16)*Math.PI*2; 
                    const cellPositions=getCellOffsets(numCells,cellLayoutScale,uniqueAngleOffset); 
                    cellPositions.forEach(pos=>{ctx.beginPath();ctx.arc(org.x+pos.x,org.y+pos.y,individualCellRadius,0,Math.PI*2);ctx.fill();}); 
                } 
                if(!org.isEgg) { 
                    if(org.flagellaCount>0){ctx.strokeStyle=org.color;ctx.lineWidth=Math.max(1,org.radius*0.1);const angleStep=(Math.PI*2)/org.flagellaCount;for(let i=0;i<org.flagellaCount;i++){const baseAngle=i*angleStep;const wave=Math.sin(simulationTime*10/gameSpeedMultiplier+baseAngle+org.id.charCodeAt(0)*0.1)*0.4;const angle=Math.atan2(org.vy,org.vx)+Math.PI+baseAngle+wave;const length=org.radius*1.2;ctx.beginPath();ctx.moveTo(org.x,org.y);ctx.lineTo(org.x+Math.cos(angle)*length,org.y+Math.sin(angle)*length);ctx.stroke();}} 
                    if(org.sightRange>0){ctx.fillStyle='rgba(255,255,255,0.8)';const eyeSize=Math.max(1.5,org.radius*0.25);const moveAngle=Math.atan2(org.vy,org.vx);ctx.beginPath();ctx.arc(org.x+Math.cos(moveAngle)*org.radius*0.5,org.y+Math.sin(moveAngle)*org.radius*0.5,eyeSize,0,Math.PI*2);ctx.fill();}} 
            }); 
            ctx.restore(); 
        }

        function gameLoop(timestamp) { update(timestamp||performance.now());draw();if(!isPaused){animationFrameId=requestAnimationFrame(gameLoop);}}
        
        function updateHeatmapButtonStates() {
            toggleScavengerHeatmapButton.classList.toggle('heatmap-button-active', showScavengerHeatmap);
            togglePreyHeatmapButton.classList.toggle('heatmap-button-active', showPreyHeatmap);
            togglePredatorHeatmapButton.classList.toggle('heatmap-button-active', showPredatorHeatmap);
        }
        
        // Function to pause the simulation if it's currently running
        function pauseSimulation() {
            if (!isPaused) {
                isPaused = true;
                pauseButton.textContent = "Resume";
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
            }
        }

        // Function to resume the simulation if it was paused by a modal
        function resumeSimulationIfModalClosed() {
            // Only resume if the game was paused and no other modal is open
            if (isPaused && pauseButton.textContent === "Resume" && 
                organismInfoModal.classList.contains('hidden') && 
                howToPlayModal.classList.contains('hidden')) {
                isPaused = false;
                pauseButton.textContent = "Pause";
                lastTickTime = performance.now();
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // Event Listeners
        window.addEventListener('resize',resizeCanvas);
        resetButton.addEventListener('click',initSimulation);
        pauseButton.addEventListener('click',()=>{
            isPaused=!isPaused;
            pauseButton.textContent=isPaused?"Resume":"Pause";
            if(!isPaused){
                lastTickTime=performance.now();
                if(animationFrameId)cancelAnimationFrame(animationFrameId);
                animationFrameId=requestAnimationFrame(gameLoop);
            }else{
                if(animationFrameId)cancelAnimationFrame(animationFrameId);
            }
        });
        
        if(speedSlider){speedSlider.addEventListener('input',()=>{gameSpeedMultiplier=parseFloat(speedSlider.value);speedValueEl.textContent=`${gameSpeedMultiplier.toFixed(1)}x`;});}
        if(maxOrganismsSlider){maxOrganismsSlider.addEventListener('input',()=>{maxOrganismsLimit=parseInt(maxOrganismsSlider.value);maxOrganismsValueEl.textContent=maxOrganismsLimit;});}

        toggleScavengerHeatmapButton.addEventListener('click',()=>{showScavengerHeatmap=!showScavengerHeatmap;updateHeatmapButtonStates();if(isPaused)draw();});
        togglePreyHeatmapButton.addEventListener('click',()=>{showPreyHeatmap=!showPreyHeatmap;updateHeatmapButtonStates();if(isPaused)draw();});
        togglePredatorHeatmapButton.addEventListener('click',()=>{showPredatorHeatmap=!showPredatorHeatmap;updateHeatmapButtonStates();if(isPaused)draw();});
        
        // Organism Info Modal Handlers
        canvas.addEventListener('click',(event)=>{
            const worldCoords=screenToWorld(event.clientX,event.clientY);
            let organismClicked=false;
            for(let i=organisms.length-1;i>=0;i--){ // Iterate backwards to click top-most organism
                const org=organisms[i];
                const dx=worldCoords.x-org.x;
                const dy=worldCoords.y-org.y;
                if(dx*dx+dy*dy<org.radius*org.radius){
                    organismClicked=true;
                    infoOrganismIdEl.textContent=`Organism ID: ${org.id} (Cells: ${org.cellCount})${org.isEgg ? ' - EGG' : ''}`;
                    infoGeneListEl.innerHTML='';
                    org.genes.forEach((geneVal,index)=>{
                        const geneEl=document.createElement('p');
                        let geneDisplayVal=geneVal.toFixed(3);
                        if(index===GENE_COMPLEXITY) geneDisplayVal=geneVal.toFixed(geneVal>10?1:3); // More precision for small complexity

                        let valueClass = 'gene-neutral'; // Default for value-based genes
                        if (GENE_THRESHOLDS.hasOwnProperty(index)) {
                            const threshold = GENE_THRESHOLDS[index];
                            if (geneVal >= threshold) {
                                valueClass = 'gene-active';
                            } else {
                                valueClass = 'gene-inactive';
                            }
                        }
                        
                        geneEl.innerHTML=`<span class="font-medium text-gray-400">${GENE_NAMES[index]||'Unknown Gene'}:</span> <span class="${valueClass}">${geneDisplayVal}</span>`;
                        infoGeneListEl.appendChild(geneEl);
                    });
                    organismInfoModal.classList.remove('hidden');
                    pauseSimulation(); // Pause when organism info modal opens
                    break; 
                }
            } 
            if(!organismClicked){ // If no organism clicked, add a husk
                husks.push({id:'husk_manual_'+Date.now()+'_'+Math.random(),x:worldCoords.x,y:worldCoords.y,radius:HUSK_DEFAULT_RADIUS, cellCount: 1});
            }
        }); 
        
        canvas.addEventListener('wheel',(event)=>{event.preventDefault();const rect=canvas.getBoundingClientRect();const mouseCanvasX=event.clientX-rect.left;const mouseCanvasY=event.clientY-rect.top;const worldMouseXBeforeZoom=(mouseCanvasX/viewScale)+viewOffsetX;const worldMouseYBeforeZoom=(mouseCanvasY/viewScale)+viewOffsetY;const zoomIntensity=0.1;const direction=event.deltaY<0?1:-1;viewScale*=(1+direction*zoomIntensity);clampViewOffset();viewOffsetX=worldMouseXBeforeZoom-(mouseCanvasX/viewScale);viewOffsetY=worldMouseYBeforeZoom-(mouseCanvasY/viewScale);clampViewOffset();if(!isPaused||isPaused)draw();});
        
        // Function to close the info modal
        function closeInfoModalAndResume(){
            organismInfoModal.classList.add('hidden');
            resumeSimulationIfModalClosed();
        }

        closeInfoModal.addEventListener('click',closeInfoModalAndResume);
        closeInfoModalButton.addEventListener('click',closeInfoModalAndResume);
        organismInfoModal.addEventListener('click',(event)=>{if(event.target===organismInfoModal)closeInfoModalAndResume();});

        // How to Play Modal Handlers
        howToPlayButton.addEventListener('click', () => {
            howToPlayModal.classList.remove('hidden');
            pauseSimulation(); // Pause when how to play modal opens
        });

        function closeHowToPlayModalAndResume() {
            howToPlayModal.classList.add('hidden');
            resumeSimulationIfModalClosed();
        }

        closeHowToPlayModal.addEventListener('click', closeHowToPlayModalAndResume);
        closeHowToPlayModalButton.addEventListener('click', closeHowToPlayModalAndResume);
        howToPlayModal.addEventListener('click', (event) => {
            if (event.target === howToPlayModal) {
                closeHowToPlayModalAndResume();
            }
        });

        // Auto-pause/resume when tab is hidden/visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Tab is hidden, pause the game
                if (!isPaused) { // Only pause if not already paused
                    isPaused = true;
                    pauseButton.textContent = "Resume";
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                }
            } else {
                // Tab is visible, resume the game
                // Only resume if the game was paused by the tab going out of focus AND no modal is open
                if (isPaused && pauseButton.textContent === "Resume" && 
                    organismInfoModal.classList.contains('hidden') && 
                    howToPlayModal.classList.contains('hidden')) {
                    isPaused = false;
                    pauseButton.textContent = "Pause";
                    lastTickTime = performance.now();
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }
        });

        // Initial Setup
        resizeCanvas(); 
        initSimulation(); 
    </script>
</body>
</html>
